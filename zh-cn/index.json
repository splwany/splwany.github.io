[{"categories":["学习笔记"],"content":"开课吧VUE体验课笔记\n day 01 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{title}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;{{state.title}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 接收obj，代理它，使他成为响应式的  // 替换Object.defineProperty()  function reactive(obj) { // vue3中基于Proxy  return new Proxy(obj, { get(target, key) { console.log(\u0026#39;get\u0026#39;, key) // 依赖收集  track(target, key) return target[key] }, set(target, key, val) { console.log(\u0026#39;set\u0026#39;, key) target[key] = val // update()  // app.update()  // 触发依赖  trigger(target, key) }, }) } // 添加副作用函数  const effectStack = [] // 临时存储fn  function effect(fn) { // 如果fn中用到了响应式数据，当他们发生变化，fn会再次执行，称为副作用函数  const eff = function() { try { effectStack.push(eff) fn() } finally { effectStack.pop() } } // 执行一次，出发依赖收集  eff() return eff } // 依赖收集函数track  // {target: {key: [eff]}}  const targetMap = {} function track(target, key) { // 获取副作用函数  const effect = effectStack[effectStack.length - 1] if (effect) { let map = targetMap[target] if (!map) { map = targetMap[target] = {} } let deps = map[key] if (!deps) { deps = map[key] = [] } // 将副作用函数放入deps  if (deps.indexOf(effect) === -1) { deps.push(effect) } } } function trigger(target, key) { const map = targetMap[target] if (map) { const deps = map[key] if (deps) { deps.forEach(dep =\u0026gt; dep()) } } } // createApp返回应用程序实例是什么样子  const Vue = { createApp(options) { // 暴露给浏览器平台  const renderer = Vue.createRenderer({ querySelector(selector) { return document.querySelector(selector) }, insert(child, parent, anchor) { parent.insertBefore(child, anchor || null) } }) return renderer.createApp(options) }, createRenderer({ querySelector, insert }) { // 返回自定义的渲染器  return { createApp(options) { // 返回的就是app实例  return { mount(selector) { // mount的目标是什么？  const parent = querySelector(selector) // 需要将组件配置解析为dom  //通过render函数实现  if (!options.render) { options.render = this.compile(parent.innerHTML) } // 兼容options api  if (options.setup) { // setupState已经是一个代理对象  this.setupState = options.setup() } else { this.data = options.data() } // Proxy  // 确定render中数据从哪获取  this.proxy = new Proxy(this, { get(target, key) { if (key in target.setupState) { return target.setupState[key] } else { return target.data[key] } }, set(target, key, val) { if (key in target.setupState) { target.setupState[key] = val } else { target.data[key] = val } } }) // app实例上加了一个更新函数  this.update = effect(() =\u0026gt; { const el = options.render.call(this.proxy) // 追加到宿主元素上去  parent.innerHTML = \u0026#39;\u0026#39; // parent.appendChild(el)  insert(el, parent) }) // 初始化  this.update() }, compile(template) { // 没有用到template  return function render() { const h3 = document.createElement(\u0026#39;h3\u0026#39;) h3.textContent = this.title return h3 } } } } } } } \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 函数式  // 2. 标准化、简化、一致性:render函数，sync修饰符删除，指令定义，v-model调整  // 3. tree-shaking（摇树优化）  // 4. 复用性：composition api  // 5. 性能优化：响应式、编译期优化  // 6. 扩展性：自定义渲染器  const { createApp } = Vue const app = createApp({ data() { return { title: \u0026#39;hello vue3!\u0026#39; } }, setup() { // 调函数等等  // 规避this  const state = reactive({ title: \u0026#39;hello vue3!!!!!!\u0026#39; }) setTimeout(() =\u0026gt; { state.title = \u0026#39;vue3, hello!!!!!!\u0026#39; }, 2000) return state }, }) // app.component()  // app.directive(\u0026#39;focus\u0026#39;, {})  app.mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; day 02 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{state.title}}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;counter: {{state2.counter}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@next\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 函数式  // 2. 标准化、简化、一致性:render函数，sync修饰符删除，指令定义，v-model调整  // 3. tree-shaking（摇树优化）  // 4. 复用性：composition api  // 5. 性能优化：响应式、编译期优化  // 6. 扩展性：自定义渲染器  const {createApp, reactive, onMounted} = Vue // 复用性  function useTitle() { const state = reactive({ title: \u0026#39;hello vue3!!!!!\u0026#39; }) onMounted(() =\u0026gt; { state.title = \u0026#39;vue3, hello!!!\u0026#39; }) setTimeout(() =\u0026gt; { state.title = \u0026#39;title 2s\u0026#39; }, 2000) return state } function useCounter() { const state2 = reactive({ counter: 0 }) onMounted(() =\u0026gt; { state2.counter = 1 }) return state2 } const app = createApp({ setup() { // title  const state = useTitle() // counter  const state2 = useCounter() // 上下文给render使用  return { state, state2 } }, }) // app.component()  // app.directive(\u0026#39;focus\u0026#39;, {})  app.mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; ","date":"2021-05-20","permalink":"/zh-cn/posts/webnotes/learn_vue/","series":["前端"],"tags":["VUE"],"title":"学习VUE"},{"categories":["学习笔记"],"content":"Javascript中的协程以及实现生产者消费者模式\n生产者消费者模式输出示例\r class Apple { static price = 10; constructor() { this.type = \u0026#39;红富士\u0026#39;; this.location = \u0026#39;邯郸\u0026#39;; this.taste = \u0026#39;甜\u0026#39;; this.price = Apple.price; } toString() { return `[${Apple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } class Penapple { static price = -817; constructor() { this.type = \u0026#39;呆湾凤梨\u0026#39;; this.location = \u0026#39;呆湾\u0026#39;; this.taste = \u0026#39;酸\u0026#39;; this.price = Penapple.price; } toString() { return `[${Penapple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } function produce (Goods) { function make (cName, i, delay = 1000) { console.log(`[生产者] 正给${cName}生产第${i}个${Goods.name}...，预计需要${delay}ms`); return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(new Goods()); }, delay); }); } return async function (c, num, delay) { const cName = c.next().value; for (let i = 1; i \u0026lt;= num; i++) { const freshGoods = await make(cName, i, delay); const cRes = c.next(freshGoods).value; console.log(`[消费者反馈] ${cRes}`); } } } function* consumer (name) { let r = name; let n; while (true) { n = yield r; if (!n) { r = \u0026#39;没给我东西啊！\u0026#39;; continue; } console.log(`[消费者 ${name}] 正买 ${n}`); r = `我是${name}，我买完了`; } } function fruitFactory (fruit) { const fruitMap = { \u0026#39;apple\u0026#39;: Apple, \u0026#39;penapple\u0026#39;: Penapple, }; if (!(fruit in fruitMap)) throw `这个工厂不能生产 ${fruit}`; return produce(fruitMap[fruit]); } (async function main() { const appleProducer = fruitFactory(\u0026#39;apple\u0026#39;); const penappleProducer = fruitFactory(\u0026#39;penapple\u0026#39;); appleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 5000); await penappleProducer(consumer(\u0026#39;张艳\u0026#39;), 5); Penapple.price = 250; penappleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 2000); })(); ","date":"2021-05-18","permalink":"/zh-cn/posts/javascripts/coroutine/","series":["前端"],"tags":["JavaScript","生产者消费者模式","协程"],"title":"JavaScript中的协程与生产者消费者模式"},{"categories":["学习笔记"],"content":"MDN文档的CSS学习笔记\n 小艳艳~\r 1. 改变元素的默认行为  当对浏览器的默认样式不太满意时，可以选定那个元素，加一条CSS规则即可。\n 例如移除无序列表 \u0026lt;ul\u0026gt; 自带的项目符号：\nli { list-style-type: none; } list-style-type属性可以使用自定义字符串甚至emoji，或很多种预设语言，可以查表。\n2. 根据状态确定样式  根据标签的状态确定样式。\n 例如使得没有被访问的链接颜色变为粉色、访问过的链接颜色变为绿色、鼠标悬停则移除下划线：\na:link { color: pink; } a:visited { color: green; } a:hover { text-decoration: none; } 3. 如何构建 CSS 在 HTML 里应用 CSS 在文档中应用 CSS 有三种方法\n外部样式表 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;link\u0026gt; 元素的 href 属性需要引用你的文件系统中的一个文件。\n内部样式表 将 CSS 直接写在 HTML 文件 \u0026lt;head\u0026gt; 标签里的 \u0026lt;style\u0026gt; 标签之中。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 内联样式 存在于 HTML 元素的 style 属性之中。每个 CSS 表只影响一个元素。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;color: blue;background-color: yellow;border: 1px solid black;\u0026#34;\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026#34;color:red;\u0026#34;\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 属性和值 在 css 中，属性和值都是区分大小写的。\r\r函数 大多数值都是简单的关键字或数值，但也有一些可能的值以函数的形式出现。例如 calc() 函数、transform属性使用的 rotate() 函数。\n规则 有些 @rules 规则很简单，有规则名和值。例如，要将额外的样式表导入主 CSS 样式表，可以使用 @import：\n@import \u0026#39;styles2.css\u0026#39;; 还有一个最常见的 @rules 之一是 @media，它允许使用媒体查询来应用 CSS，仅当某些条件成立（例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时）。\nbody { background-color: pink; } @media (min-width: 30em) { body { background-color: blue; } } 速记属性 一些常用的：\ndiv { padding: 10px 15px 15px 5px; } 与这四行代码是等价的：\ndiv { padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; } div { background: red url(bg-graphic.png) 10px 10px repeat-x fixed; } 与这五行代码是等价的：\ndiv { background-color: red; background-image: url(bg-graphic,png); background-position: 10px 10px; background-repeat: repeat-x; background-attachment: fixed; } 4. CSS 如何运行 CSS运行过程\r 一个真实的 DOM 案例 现在通过一个 HTML 片段来了解 HTML 怎么转化成 DOM\n\u0026lt;p\u0026gt; Let\u0026#39;s use: \u0026lt;span\u0026gt;Cascading\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Style\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Sheets\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; 对应树形结构为：\nP ├─ \u0026#34;Let\u0026#39;s use:\u0026#34; ├─ SPAN | └─ \u0026#34;Cascading\u0026#34; ├─ SPAN | └─ \u0026#34;Style\u0026#34; └─ SPAN └─ \u0026#34;Sheets\u0026#34; 当浏览器遇到无法解析的 CSS 代码会发生什么 浏览器什么也不会做，继续解析下一个 CSS 样式。\n相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个 CSS 选择器。\n因此，当为一个元素指定多个 CSS 样式的时候，浏览器会加载样式表中的最后的 CSS 代码进行渲染，正因为如此，可以为同一个元素指定多个 CSS 样式来解决有些浏览器不兼容新特性的问题。\n5. 层叠与继承 冲突规则 层叠 当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n优先级 内联 \u0026gt; id \u0026gt; class \u0026gt; tag\n继承 一些设置在父元素上的 css 属性是可以被子元素继承的，有些则不能。\n例如 color 会继承，但 width 不会继承。因为如果复元素的 width 是50%，后代继承 width，那 CSS 就会很难使用了！\n控制继承 CSS 为控制继承提供了四个特殊的通用属性值。每个 css 属性都接收这些值。\ninherit：使该元素属性和父元素相同。即：开启继承。\ninitial：设置为元素属性的初始默认值，默认值由官方 CSS 规范定义。如果没有默认值且该属性是自然继承的，那么会设置为 inherit。\nunset：重置为自然值，即：如果属性是自然继承那么就是 inherit，否则和 initial 一样。\nrevert: 使该元素样式还原成样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置，否则，按浏览器定义样式表中的样式设置，否则，等价于 unset。\n 通俗解释就是：\n 设置了 inherit 就是继承来自祖上的东西。 设置了 initial 就是抛弃祖上的东西另起炉灶从默认值开始，如果没有默认值，就接着继承祖上的东西。 设置了 unset 就是我不发表意见，本来是继承就继承，本来是默认就默认。 设置了 revert 就是推翻一切，从默认样式表重新开始。   重设所有属性值 CSS 的 shorthand 属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(inherit, initial, unset, or revert)。这是一种撤销对样式所作更改的简便方法，以便回到之前已知的起点。\n.fix-this { all: unset; } ","date":"2021-05-16","permalink":"/zh-cn/posts/webnotes/learn_css/","series":["前端"],"tags":["CSS"],"title":"学习CSS"},{"categories":["学习笔记"],"content":"Python的一些使用技巧和有趣的库\n 1. dataclasses  python3.7引入的内置库，实现数据类，可以利用上内置的类型提示\n 使用方法：\nimport dataclasses as dc @dc.dataclass class Person: name: str # 简单说明类型 age: int = 0 # 设置默认值 sex: str = dc.field(default=\u0026#39;male\u0026#39;, repr=False) # 除了默认值，还可通过repr设置是否显示在字符串输出中 # 创建一个Person实例 p1 = Person(\u0026#39;zhangyan\u0026#39;, 25, \u0026#39;female\u0026#39;) print(p1) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;) 还可以通过asdict和astuple将其转换为dict和tuple类型：\nprint(dc.asdict(p1)) # {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(dc.astuple(p1)) # (\u0026#39;zhangyan\u0026#39;, 25, female) dict类型转为dataclass\np2 = {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(Person(**p2)) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;)  2. namedtuple  给元组命名，元组中的每一项也可以命名；\n创建的元组实例内的值是不能更改的，但可以使用_replace()方法更改值后返回一个新的元组；\n也可以当作一行代码定义一个类；\n也可以当作数据类用，但是无法使用内置的类型提示，不如dataclasses。\n 使用方法：\nfrom collections import namedtuple Color = namedtuple(\u0026#39;Color\u0026#39;, \u0026#39;r g b a\u0026#39;, defaults=[1.0]) # \u0026#39;r g b a\u0026#39;还可以写为\u0026#39;r, g, b, a\u0026#39;或[\u0026#39;r\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] red = Color(255, 0, 0) # 红色 green = Color(0, 255, 0) # 绿色 blue = Color(0, 0, 255) # 蓝色 half_blue = Color(0, 0, 255, 0.5) # 透明度为50%的蓝色 print(half_blue) # Color(r=0, g=0, b=255, a=0.5) half_blue = half_blue._replace(g=233) print(half_blue) orange = Color._make([224, 142, 0, 1]) # 使用_make函数通过传入一个可迭代对象来构建实例，设置了默认值的项依旧不能省略 print(orange) print(orange._asdict()) # OrderedDict([(\u0026#39;r\u0026#39;, 224), (\u0026#39;g\u0026#39;, 142), (\u0026#39;b\u0026#39;, 0), (\u0026#39;a\u0026#39;, 1)]) print(tuple(orange)) # (224, 142, 0, 1)  3. threading  实现类似 JavaScript 中的 setimeout 延迟运行的效果\n 使用方法：\nimport threading def settimeout(func, delay, *args, **kwargs): threading.Timer(delay, func, args, kwargs).start() # 隔一秒输出一个 i，依次为 0 1 2 3 4 for i in range(5): settimeout(lambda x: print(x), i + 1, i) # 隔一秒输出一个 i，依次为 4 4 4 4 4 for i in range(5): settimeout(lambda x: print(i), i + 1, i) # 一秒后一起输出，依次为 44444 for i in range(5): settimeout(lambda x: print(i, end=\u0026#39;\u0026#39;), 1, i) # 一秒后一起输出，顺序随机，例如：43201、12340 for i in range(5): settimeout(lambda x: print(x, end=\u0026#39;\u0026#39;), 1, i) ","date":"2021-05-12","permalink":"/zh-cn/posts/pythons/python_tips/","series":["python"],"tags":["dataclasses","namedtuple","threading"],"title":"Python小贴士"},{"categories":["待办"],"content":"面试大厂需要了解的知识点\n1. Webpack VS Vite 原理   谈谈 AST 语法树？ 谈谈 babel 的作用？ 如何收集代码依赖？ ES Module 与 CMD 区别？   如何搞懂 webpack 原理呢？手写一个 mini-webpack 是非常直接的方法，比去看原理解析文章效率高多了。\r\r需要做的有：\n 造个轮子 - 手写 Webpack 什么是抽象语法树（AST） 如何分析模块的依赖关系 如何将 ES6 转换为 ES5 读懂 bundle 文件中的天书代码 谁会是下一个 Webpack ","date":"2021-05-06","permalink":"/zh-cn/posts/webnotes/questions/","series":["前端"],"tags":["面试问题"],"title":"待学习的知识"},{"categories":["学习笔记"],"content":"MDN文档的HTML学习笔记\n 1. 嵌入 \u0026lt;iframe\u0026gt; 元素\r sandbox属性 该属性需要在已经支持其他\u0026lt;iframe\u0026gt;功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置。\r\r注意：为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的src属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间。\r\r\u0026lt;embed\u0026gt; 和 \u0026lt;object\u0026gt; 元素\r 这两个元素与\u0026lt;iframe\u0026gt;不同，是用来嵌入多种类型的外部内容的通用嵌入工具，包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容。\n插件是一种对浏览器原生无法读取的内容提供访问权限的软件\r\r 2. 矢量图形SVG\r 快捷方式：\u0026lt;img\u0026gt; 使用 src 属性设置SVG路径\n疑难解答和跨浏览器支持 对于不支持SVG（IE 8及更低版本，Android 2.3 及更低版本）的浏览器，可以从 src 属性引用 PNG 或 JPG ，并使用 srcset 属性 只有最近的浏览器才能识别）来引用 SVG 。 在这种情况下，仅支持浏览器将加载 SVG - 较旧的浏览器将加载 PNG ：\n\u0026lt;img src=\u0026#34;equilateral.png\u0026#34; alt=\u0026#34;triangle with equal sides\u0026#34; srcset=\u0026#34;equilateral.svg\u0026#34;\u0026gt; 还可以使用 SVG 作为 CSS 背景图像，如下所示。 在下面的代码中，旧版浏览器会坚持他们理解的 PNG ，而较新的浏览器将加载 SVG ：\n.svg { background: url(\u0026#34;fallback.png\u0026#34;) no-repeat center; background-image: url(\u0026#34;image.svg\u0026#34;); background-size: contain; } 像上面描述的\u0026lt;img\u0026gt;方法一样，使用 CSS 背景图像插入 SVG 意味着它不能被 JavaScript 操作，并且也受到相同的 CSS 限制。\n在HTML中引入SVG代码  可以在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中 - 这有时称为将SVG内联或内联SVG。确保您的SVG代码在\u0026lt;svg\u0026gt;\u0026lt;/svg\u0026gt;标签中（不要在外面添加任何内容）。\n \u0026lt;svg width=\u0026#34;300\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; fill=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; 优点  将 SVG 内联减少 HTTP 请求，可以减少加载时间。 可以为 SVG 元素分配class和id，并使用 CSS 修改样式。 内联 SVG 是唯一可以在 SVG 图像上使用 CSS 交互（如:focus）和 CSS 动画的方法（即使在常规样式表中）。 可以通过将 SVG 标记包在 \u0026lt;a\u0026gt; 元素中，使其成为超链接。  缺点  这种方法只适用于在一个地方使用的 SVG 。多次使用会导致资源密集型维护（resource-intensive maintenance）。 额外的 SVG 代码会增加 HTML 文件的大小。 浏览器不能像缓存普通图片一样缓存内联 SVG 。 可能会在 \u0026lt;foreignObject\u0026gt; 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。考虑一下仅仅为支持过时的浏览器，而增加额外开销是否真的值得。  示例 遁入智瞳！上勾拳！     3. 响应式图片  目的：学习如何使用 srcset 以及 \u0026lt;picture\u0026gt; 元素，来实现网页中的响应式图片处理方法。\n 新特性 srcset / sizes / \u0026lt;picture\u0026gt; —— 都已经被新版本的现代浏览器和移动浏览器支持。\r\r 分辨率切换：不同的尺寸 两个新属性：srcset 和 sizes 提供额外的资源图像和提示。\n  浏览器根据设备宽度到 sizes 中找到不超过 max-width 的那一项 根据此项后面的像素值 a，到 srcset 中找到不小于这个值的最接近的 b 将 srcset 对应的图片路径作为需要显示的图片路径，以达到省流目的   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/water-320w.jpg 320w, /images/posts/webnotes/learn_html/water-480w.jpg 480w, /images/posts/webnotes/learn_html/water-800w.jpg 800w, /images/posts/webnotes/learn_html/water-1280w.jpg 1280w\u0026#34; sizes = \u0026#34;(max-width: 424px) 320px, (max-width: 767px) 460px, (max-width: 991px) 800px, 1280px\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/water-1280w.jpg\u0026#34; alt=\u0026#34;Drink more water\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕大小下载合适的图片，来省流。\r\r 分辨率切换：相同的尺寸，不同的分辨率 如果想支持多分辨率显示，但希望每个人在屏幕上看到的图片的实际尺寸是相同的，使用 srcset 和 x 语法结合——一种更简单的语法——而不用 sizes ，来选择适当分辨率的图片。\n  浏览器根据设备的 DPR（即设备像素比），从 srcset 中找到像素比最接近的图片路径 将此路径的图片显示出来，图片的大小由 CSS 样式表中的 width 值来定义 浏览器会保证图片在任何设备上的物理大小一致   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png, /images/posts/webnotes/learn_html/mercy-480w.png 1.5x, /images/posts/webnotes/learn_html/mercy-800w.png 2.5x, /images/posts/webnotes/learn_html/mercy-1280w.png 4x\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34; style=\u0026#34;width: 180px;\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕像素密度来决定使用哪个版本的图片，并根据 `width` 的值保证图片在所有设备上实际大小一致。\r\r 美术设计  使用 \u0026lt;picture\u0026gt; 元素实现当屏幕缩小时动态得使用对应像素的图片，将内容适应小屏幕观看，例如人物更大的低分辨率图片。\n \u0026lt;picture\u0026gt; \u0026lt;!-- 小手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 424px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png\u0026#34;\u0026gt; \u0026lt;!-- 大手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 767px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-480w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑竖屏 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 991px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-800w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑横屏 / 笔记本电脑 --\u0026gt; \u0026lt;source srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.jpg\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 效果（调整浏览器宽度以查看变化）：\n   应该仅仅在美术设计场景下使用media属性；当使用media时，不要在sizes属性中也提供媒体条件。\r\r 为什么不能使用 CSS 或 JavaScript 来做到这一效果？ 如果使用CSS或JavaScript来实现这一效果，在这之前原始图像已经被加载了，然后CSS或JavaScript又加载了一个小的图像，反而浪费发了流量。\n 大胆使用现代图像格式 新图像格式（例如 WebP 和 JPEG-2000）可以在有高质量的同时有较低的文件大小。但是浏览器支持情况不同。\n可以使用 \u0026lt;picture\u0026gt; 来继续满足老式浏览器的需要。可以在 type 属性中提供 MIME 类型，这样浏览器就能立即拒绝不支持的类型：\n\u0026lt;picture\u0026gt; \u0026lt;source type=\u0026#34;image/svg+xml\u0026#34; srcset=\u0026#34;***.svg\u0026#34;\u0026gt; \u0026lt;source type=\u0026#34;image/webp\u0026#34; srcset=\u0026#34;***.webp\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;***.png\u0026#34; alt=\u0026#34;example image\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt;  不要使用 media 属性，除非需要美术设计。 在 \u0026lt;source\u0026gt; 元素中，只可以引用在 type 中声明的文件类型。 如果必要，可以在 srcset 和 sizes 中使用逗号分割的列表。 ","date":"2021-05-05","permalink":"/zh-cn/posts/webnotes/learn_html/","series":["前端"],"tags":["HTML"],"title":"学习HTML"},{"categories":["Shortcode"],"content":"本文展示了如果使用 alert shortcode。\n{{\u0026lt; alert \u0026#34;Message\u0026#34; [type] \u0026gt;}}  The parameter type is optional. Default to info.\n Info {{\u0026lt; alert \u0026#34;Info\u0026#34; \u0026gt;}} Info\r\rSuccess {{\u0026lt; alert \u0026#34;Success\u0026#34; success \u0026gt;}} Success\r\rWarning {{\u0026lt; alert \u0026#34;Warning\u0026#34; warning \u0026gt;}} Warning\r\rDanger {{\u0026lt; alert \u0026#34;Danger\u0026#34; danger \u0026gt;}} Danger\r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/alert/","series":["用户手册"],"tags":["Alert"],"title":"Alert Shortcode"},{"categories":["Shortcode"],"content":"关于哔哩哔哩 shortcode 的详细使用说明。\n使用 {{\u0026lt; bilibili \u0026#34;video id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/bilibili/","series":null,"tags":["哔哩哔哩"],"title":"Bilibili Shortcode"},{"categories":["Shortcode"],"content":"关于 CodePen shortcode 的详细说明。\n使用 {{\u0026lt; codepen \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/codepen/","series":null,"tags":["CodePen"],"title":"CodePen Shortcode"},{"categories":["Shortcode"],"content":"关于 JSFiddle shortcode 的详细说明。\n使用 {{\u0026lt; jsfiddle \u0026#34;user/id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/jsfiddle/","series":null,"tags":["JSFiddle"],"title":"JSFiddle Shortcode"},{"categories":["Shortcode"],"content":"关于 JSRun shortcode 的详细说明。\n使用 {{\u0026lt; jsrun \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/jsrun/","series":null,"tags":["JSRun"],"title":"JSRun Shortcode"},{"categories":["Shortcode"],"content":"关于优酷 shortcode 的详细说明。\n使用 {{\u0026lt; youku \u0026#34;XNTQwMTgxMTE2\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/youku/","series":null,"tags":["Youku"],"title":"优酷 Shortcode"},{"categories":["Shortcode"],"content":"关于爱奇艺 shortcode 的详细说明。\n使用 {{\u0026lt; iqiyi \u0026#34;vid\u0026#34; \u0026#34;tvid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/iqiyi/","series":null,"tags":["爱奇艺"],"title":"爱奇艺 Shortcode"},{"categories":["Shortcode"],"content":"关于网易云音乐 Shortcode 的详细使用说明。\n使用 {{\u0026lt; neteasemusic \u0026#34;id\u0026#34; [auto [type]] \u0026gt;}}    Parameter Description     auto The auto controls whether to autoplay. Boolean and optional, default to false.   type The type parameter is optional. Default to 2.    例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/neteasemusic/","series":null,"tags":["网易云音乐"],"title":"网易云音乐 Shortcode"},{"categories":["Shortcode"],"content":"关于腾讯视频 shortcode 的详细说明。\n使用 {{\u0026lt; tencentvideo \u0026#34;vid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/tencentvideo/","series":null,"tags":["腾讯视频"],"title":"腾讯视频 Shortcode"}]