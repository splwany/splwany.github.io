[{"categories":["学习笔记"],"content":"YOLOV5模型部署到Android的过程记录，系统环境：Ubuntu\n 1. PyTorch模型转ONNX 1.1 进入yolov5根目录，执行如下命令 cd path/to/yolov5 python models/export.py --weights runs/train/exp/weights/best.pt --train --include onnx 其中第二行命令中的--weights指保存的参数文件；\n--train表示模型以train模式进行，主要是根据yolov5的代码来看，需要导出train模式的网络结构，因为forward需要return三个输出，如果是val模式，输出的不是这种格式；\n--include表示需要导出的目标格式有哪些，因为目前只需要onnx，所以需要只写onnx，默认导出各种支持的格式\n1.2 进入onnx文件所在目录，简化onnx cd path/to/yolov5/runs/train/exp/weights python -m onnxsim best.onnx best-sim.onnx 其中模块onnxsim是需要下载的，使用pip install onnx-simplifier； 安装完onnx-simplifier后即可使用如上命令来简化onnx文件，得到best-sim.onnx；\n2. ONNX转NCNN 2.1 下载ncnn预编译版本 可以到github下载ncnn源码\r并自行编译，本文只讲预编译版本\r的使用。\n我的环境是Ubuntu16，所以下载的是ncnn-20210525-ubuntu-1604-shared.zip\r。目前不清楚shared版和无shared版的区别，不过貌似不带shared的版本缺一些东西导致报错。\n将压缩文件解压后即可使用ncnn了。\n2.2 进入onnx文件所在目录，并转化为ncnn的param文件和bin文件 cd path/to/yolov5/runs/train/exp/weights path/to/ncnn/bin/onnx2ncnn best-sim.onnx yolov5s-traffic.param yolov5s-traffic.bin 不出所料，转化完成，但是出现如下报错：\n转换过程中有一些不支持的结构\r 此时需要手动修改生成的param文件来解决错误。\n2.3 修改param文件中的内容来更改网络结构 下图为param文件修改前的情况：\n修改前的内容\r 转换错误的层为5到12行的Crop操作，因此需要将4到13行全部删除并体会为自定义层YoloV5Focus。因为一共减少了9层，所以将第2行的第1个值减9：\n换为自定义层后的内容\r 另外，网络最后有三个reshape层，我们需要实现输入任意尺寸的图片，因此需要将位置0的大小改为-1以实现自动计算大小：\n修改reshape层的内容\r 2.4 优化param文件和bin文件 path/to/ncnn/bin/ncnnoptimize yolov5s-traffic.param yolov5s-traffic.bin yolov5s-traffic-opt.param yolov5s-traffic-opt.bin 1 其中末尾的1表示将float32优化为float16以降低文件大小。\n","date":"2021-06-21","permalink":"https://splwany.github.io/zh-cn/posts/pythons/pytorch_to_android/","series":["deep learning"],"tags":["pytorch","yolov5","android","onnx","ncnn"],"title":"PyTorch模型部署到Android"},{"categories":["学习笔记"],"content":"深度学习超强大的一款可视化工具\n 1. 安装 pip install wandb 2. 使用 import wandb # 使用自己的 W\u0026amp;B 账号登录 wandb.login() # 开启一个新的 run 来追踪 wandb.init( # 指定项目名称 project=\u0026#34;basic-intro\u0026#34;, # 跟踪超参数并运行元数据 config={ \u0026#34;learning_rate\u0026#34;: 0.02, \u0026#34;architecture\u0026#34;: \u0026#34;CNN\u0026#34;, \u0026#34;dataset\u0026#34;: \u0026#34;CIFAR-100\u0026#34;, } ) # 在需要显示的地方使用如下方式 wandb.log({ \u0026#34;acc\u0026#34;: acc, \u0026#34;loss\u0026#34;: loss, }) # 结束 wandb.finish() 官方文档\r","date":"2021-06-02","permalink":"https://splwany.github.io/zh-cn/posts/pythons/weights_and_biases/","series":["deep learning"],"tags":["wandb"],"title":"Weights \u0026 Biases 深度学习可视化工具"},{"categories":["学习笔记"],"content":"JavaScript中的继承、原型、原型链，以及类的创建\n1. 继承  JavaScript中有6种继承方式：基本继承、借用构造函数、组合继承、原型式继承、寄生式继承、寄生组合式继承\n 1.1 基本继承 function Parent() {} Parent.prototype.method1() {} function Child() {} Child.prototype = new Parent() Child.prototype.constructor = Child 即通过将Parent的一个实例直接作为子类Child的原型对象，所有Child实例都通过__proto__指向这个Parent实例。\n弊端：\n  原型对象中的所有引用类型的值会被子类共享\n  无法在构造子类的时候向父类的构造函数动态传值\n  因此，这种继承方式几乎很少单独使用，但当父类只是定义了一些方法时，仍然可以使用该方式。\n1.2 借用构造函数 function Parent(name, age) { this.name = name this.age = age } // 使用new来创建一个示例 const parent = new Parent(\u0026#39;Alan Wei\u0026#39;, 26) // new的实现原理类似如下函数 function newObj(constructor, ...args) { const tmp = {} tmp.__proto__ = constructor.prototype constructor.call(tmp, ...args) return tmp } const parent2 = newObj(Parent, \u0026#39;Alan Wei\u0026#39;, 26) 思考一下，既然构造函数可以用来构造空对象，为什么不能用来构造子类实例呢？比如：\nfunction Child(name, age) { Parent.call(this, name, age) } const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 此时，我们“借用”了Parent的构造函数作为构造规则，为Child创建了实例（使用new调用Child时，内部的this就是一个Child实例）。现在我们在Parent构造函数中定义的所有属性和方法都会给当前Child实例重新定义一遍，从而实现了继承。\n解决了第一种继承方式的两大弊端：\n  引用类型属性的共享。现在每个子类实例的属性都是借用父类构造函数新定义的，因此相互独立。\n  无法向父类构造函数动态传值。现在向Child传入的参数又被传给了父类构造函数，因此该问题也得到了解决。\n  缺点：\n父类的所有属性和方法都需要重新构造一遍，导致方法无法被共享，每个子类都需要维护一个相同的方法，失去了继承的本质。\n因此，我们可以考虑融合上面两种方法的优点，创造一种更好的继承方式。\n1.3 组合继承 组合使用上述两种继承方式，来实现方法的共享和属性的独立构造。通用习惯就是，把属性放在父类的构造函数中，把方法放在父类的原型上。\nfunction Child(name, age) { Parent.call(this, name, age) } Child.prototype = new Parent() // Child中定义自己的constructor指向，否则会自动通过原型链使用父类原型对象上的constructor Child.constructor = Child 但这种方式并非完美，实际上需要调用父类构造函数两次：\nfunction Child(name, age) { Parent.call(this, name, age) // 第二次调用Parent的构造函数 } Child.prototype = new Parent() // 第一次调用Parent的构造函数 Child.constructor = Child const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 既然子类会有Parent构造出来属性，必然屏蔽Child原型对象上Parent实例属性，那为什么还要浪费时间和内存去构造它呢？为了解决这个问题，又衍生出下面的继承方式。\n1.4 原型式继承 与基本继承的原型式继承的不同之处在于，这是一种更“干净”的实现，它只继承父类的原型，而不继承父类构造函数中的属性（及可能存在的方法）。\nfunction createObj( prototype ) { // 重建一个空构造函数  function F(){} // 将该构造函数的原型链替换为传入的原型对象  F.prototype = prototype // 创建并返回一个空对象，但该对象的__proto__指向传入的prototype  return new F() } // child是个空对象，但可以借助原型链访问Parent的原型属性和方法 const child = createObj(Parent.prototype) 上面这种方式在ES5中得到了原生实现，即Object.create()方法，可以传入一个原型对象进去，构造一个以该原型为原型的空对象，这在某些轻量级的继承场景中是十分便捷的：\nconst child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 26 该继承方式显然有着自己的缺陷，但它却为解决组合继承的重复构造问题提供了思路。在介绍如何通过原型式继承来解决组合继承遇到的问题之前，我们再介绍另外一种继承方式 - 寄生式继承，它是原型式继承的工厂化版本。\n1.5 寄生式继承 在上面的原型式继承中，我们创建了一个空的子类对象之后，需要手动为其添加自有的属性和方法，如：\nconst child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 26 上述三条语句都是用于构造子类对象的，但却是独立的，我们认为这样耦合性较差，封装程度不够，因此我们通常会将其封装为一个函数：\nfunction createChild(Parent) { const child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 24 } const child = createChild(Parent) 当我们定义了上述函数之后，每次构造一个子类对象，只需要写下面的一行语句即可，代码看上去也优雅了很多，这就是所谓的寄生式继承。所以，寄生式继承就是原型式继承的一个工厂化（将一系列流程封装在一起，进行快速批量生产）版本。\n显然寄生式继承并不是为了解决原型式继承的问题而存在的。接下来我们就来了解一种更加优雅的继承方式 - 寄生式组合继承。\n1.6 寄生组合式继承 思路：用原型式继承替换组合继承中的基本继承\nfunction Parent(name, age) { this.name = name this.age = age } Parent.prototype.method1 = function() {} function Child(name, age) { Parent.call(this, name, age) } Child.prototype = Object.create(Parent.prototype) Child.prototype.constructor = Child const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 目前，寄生组合式继承被认为是JavaScript实现继承的一种比较理想的方式。\n","date":"2021-05-22","permalink":"https://splwany.github.io/zh-cn/posts/javascripts/prototype_chain/","series":["前端"],"tags":["JavaScript","prototype","继承","原型链","ES5","ES6"],"title":"JavaScript继承、原型和原型链"},{"categories":["学习笔记"],"content":"开课吧VUE体验课笔记\n \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{title}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;{{state.title}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 接收obj，代理它，使他成为响应式的  // 替换Object.defineProperty()  function reactive(obj) { // vue3中基于Proxy  return new Proxy(obj, { get(target, key) { console.log(\u0026#39;get\u0026#39;, key) // 依赖收集  track(target, key) return target[key] }, set(target, key, val) { console.log(\u0026#39;set\u0026#39;, key) target[key] = val // update()  // app.update()  // 触发依赖  trigger(target, key) }, }) } // 添加副作用函数  const effectStack = [] // 临时存储fn  function effect(fn) { // 如果fn中用到了响应式数据，当他们发生变化，fn会再次执行，称为副作用函数  const eff = function() { try { effectStack.push(eff) fn() } finally { effectStack.pop() } } // 执行一次，出发依赖收集  eff() return eff } // 依赖收集函数track  // {target: {key: [eff]}}  const targetMap = {} function track(target, key) { // 获取副作用函数  const effect = effectStack[effectStack.length - 1] if (effect) { let map = targetMap[target] if (!map) { map = targetMap[target] = {} } let deps = map[key] if (!deps) { deps = map[key] = [] } // 将副作用函数放入deps  if (deps.indexOf(effect) === -1) { deps.push(effect) } } } function trigger(target, key) { const map = targetMap[target] if (map) { const deps = map[key] if (deps) { deps.forEach(dep =\u0026gt; dep()) } } } function h(tag, props, children) { return {tag, props, children} } // createApp返回应用程序实例是什么样子  const Vue = { createApp(options) { // 暴露给浏览器平台  const renderer = Vue.createRenderer({ querySelector(selector) { return document.querySelector(selector) }, insert(child, parent, anchor) { parent.insertBefore(child, anchor || null) }, createElement(tag) { return document.createElement(tag) } }) return renderer.createApp(options) }, createRenderer({ querySelector, insert, createElement }) { // 返回自定义的渲染器  return { createApp(options) { // 返回的就是app实例  return { mount(selector) { // mount的目标是什么？  const parent = querySelector(selector) // 需要将组件配置解析为dom  //通过render函数实现  if (!options.render) { options.render = this.compile(parent.innerHTML) } // 兼容options api  if (options.setup) { // setupState已经是一个代理对象  this.setupState = options.setup() } else { this.data = options.data() } // Proxy  // 确定render中数据从哪获取  this.proxy = new Proxy(this, { get(target, key) { if (key in target.setupState) { return target.setupState[key] } else { return target.data[key] } }, set(target, key, val) { if (key in target.setupState) { target.setupState[key] = val } else { target.data[key] = val } } }) // app实例上加了一个更新函数  this.update = effect(() =\u0026gt; { // const el = options.render.call(this.proxy)  // // 追加到宿主元素上去  // parent.innerHTML = \u0026#39;\u0026#39;  // // parent.appendChild(el)  // insert(el, parent)  // 获取虚拟dom  const vnode = options.render.call(this.proxy) // mounted  if (!this.isMounted) { // mounted  // vnode =\u0026gt; dom  const el = this.createElm(vnode) parent.innerHTML = \u0026#39;\u0026#39; insert(el, parent) this.isMounted = true } else { // update  // diff  this.patch(this._vnode, vnode) } this._vnode = vnode }) // 初始化  this.update() }, createElm(vnode) { // 创建根节点  const el = createElement(vnode.tag) // todo props  // children  if (typeof vnode.children === \u0026#39;string\u0026#39;) { el.textContent = vnode.children } else { // 递归  vnode.children.forEach(child =\u0026gt; { insert(this.createElm(child), el) }) } vnode.el = el return el }, // n1: 老节点  // n2: 新节点  patch(n1, n2) { const el = n2.el = n1.el // 判断双方是否是相同节点  if (n1.tag === n2.tag) { // tots props  // children  const oldCh = n1.children const newCh = n2.children if (typeof oldCh === \u0026#39;string\u0026#39;) { if (typeof newCh === \u0026#39;string\u0026#39;) { // text  if (oldCh !== newCh) { el.textContent = newCh } } else { // replace text with elements  el.textContent = \u0026#39;\u0026#39; newCh.forEach(child =\u0026gt; insert(this.createElm(child), el)) } } else { if (typeof newCh === \u0026#39;string\u0026#39;) { // replace elements with text  el.textContent = newCh } else { // children  } } } }, compile(template) { // 没有用到template  return function render() { // const h3 = document.createElement(\u0026#39;h3\u0026#39;)  // h3.textContent = this.title  // return h3  // 返回vnode  return h(\u0026#39;h3\u0026#39;, null, this.title) // return h(\u0026#39;h3\u0026#39;, null, [  // h(\u0026#39;p\u0026#39;, null, this.title),  // ])  } } } } } } } \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 函数式  // 2. 标准化、简化、一致性:render函数，sync修饰符删除，指令定义，v-model调整  // 3. tree-shaking（摇树优化）  // 4. 复用性：composition api  // 5. 性能优化：响应式、编译期优化  // 6. 扩展性：自定义渲染器  const { createApp } = Vue const app = createApp({ data() { return { title: \u0026#39;hello vue3!\u0026#39; } }, setup() { // 调函数等等  // 规避this  const state = reactive({ title: \u0026#39;hello vue3!!!!!!\u0026#39; }) setTimeout(() =\u0026gt; { state.title = \u0026#39;vue3, hello!!!!!!\u0026#39; }, 2000) return state }, }) // app.component()  // app.directive(\u0026#39;focus\u0026#39;, {})  app.mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; ","date":"2021-05-20","permalink":"https://splwany.github.io/zh-cn/posts/webnotes/learn_vue/","series":["前端"],"tags":["VUE"],"title":"学习VUE"},{"categories":["学习笔记"],"content":"JavaScript中的协程以及实现生产者消费者模式\n生产者消费者模式输出示例\r class Apple { static price = 10; constructor() { this.type = \u0026#39;红富士\u0026#39;; this.location = \u0026#39;邯郸\u0026#39;; this.taste = \u0026#39;甜\u0026#39;; this.price = Apple.price; } toString() { return `[${Apple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } class Penapple { static price = -817; constructor() { this.type = \u0026#39;呆湾凤梨\u0026#39;; this.location = \u0026#39;呆湾\u0026#39;; this.taste = \u0026#39;酸\u0026#39;; this.price = Penapple.price; } toString() { return `[${Penapple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } function produce (Goods) { function make (cName, i, delay = 1000) { console.log(`[生产者] 正给${cName}生产第${i}个${Goods.name}...，预计需要${delay}ms`); return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(new Goods()); }, delay); }); } return async function (c, num, delay) { const cName = c.next().value; for (let i = 1; i \u0026lt;= num; i++) { const freshGoods = await make(cName, i, delay); const cRes = c.next(freshGoods).value; console.log(`[消费者反馈] ${cRes}`); } } } function* consumer (name) { let r = name; let n; while (true) { n = yield r; if (!n) { r = \u0026#39;没给我东西啊！\u0026#39;; continue; } console.log(`[消费者 ${name}] 正买 ${n}`); r = `我是${name}，我买完了`; } } function fruitFactory (fruit) { const fruitMap = { \u0026#39;apple\u0026#39;: Apple, \u0026#39;penapple\u0026#39;: Penapple, }; if (!(fruit in fruitMap)) throw `这个工厂不能生产 ${fruit}`; return produce(fruitMap[fruit]); } (async function main() { const appleProducer = fruitFactory(\u0026#39;apple\u0026#39;); const penappleProducer = fruitFactory(\u0026#39;penapple\u0026#39;); appleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 5000); await penappleProducer(consumer(\u0026#39;张艳\u0026#39;), 5); Penapple.price = 250; penappleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 2000); })(); ","date":"2021-05-18","permalink":"https://splwany.github.io/zh-cn/posts/javascripts/coroutine/","series":["前端"],"tags":["JavaScript","生产者消费者模式","协程"],"title":"JavaScript中的协程与生产者消费者模式"},{"categories":["学习笔记"],"content":"MDN文档的CSS学习笔记\n 小艳艳~\r 1. 改变元素的默认行为  当对浏览器的默认样式不太满意时，可以选定那个元素，加一条CSS规则即可。\n 例如移除无序列表 \u0026lt;ul\u0026gt; 自带的项目符号：\nli { list-style-type: none; } list-style-type属性可以使用自定义字符串甚至emoji，或很多种预设语言，可以查表。\n2. 根据状态确定样式  根据标签的状态确定样式。\n 例如使得没有被访问的链接颜色变为粉色、访问过的链接颜色变为绿色、鼠标悬停则移除下划线：\na:link { color: pink; } a:visited { color: green; } a:hover { text-decoration: none; } 3. 如何构建 CSS 在 HTML 里应用 CSS 在文档中应用 CSS 有三种方法\n外部样式表 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;link\u0026gt; 元素的 href 属性需要引用你的文件系统中的一个文件。\n内部样式表 将 CSS 直接写在 HTML 文件 \u0026lt;head\u0026gt; 标签里的 \u0026lt;style\u0026gt; 标签之中。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 内联样式 存在于 HTML 元素的 style 属性之中。每个 CSS 表只影响一个元素。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;color: blue;background-color: yellow;border: 1px solid black;\u0026#34;\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026#34;color:red;\u0026#34;\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 属性和值 在 css 中，属性和值都是区分大小写的。\r\r函数 大多数值都是简单的关键字或数值，但也有一些可能的值以函数的形式出现。例如 calc() 函数、transform属性使用的 rotate() 函数。\n规则 有些 @rules 规则很简单，有规则名和值。例如，要将额外的样式表导入主 CSS 样式表，可以使用 @import：\n@import \u0026#39;styles2.css\u0026#39;; 还有一个最常见的 @rules 之一是 @media，它允许使用媒体查询来应用 CSS，仅当某些条件成立（例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时）。\nbody { background-color: pink; } @media (min-width: 30em) { body { background-color: blue; } } 速记属性 一些常用的：\ndiv { padding: 10px 15px 15px 5px; } 与这四行代码是等价的：\ndiv { padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; } div { background: red url(bg-graphic.png) 10px 10px repeat-x fixed; } 与这五行代码是等价的：\ndiv { background-color: red; background-image: url(bg-graphic,png); background-position: 10px 10px; background-repeat: repeat-x; background-attachment: fixed; } 4. CSS 如何运行 CSS运行过程\r 一个真实的 DOM 案例 现在通过一个 HTML 片段来了解 HTML 怎么转化成 DOM\n\u0026lt;p\u0026gt; Let\u0026#39;s use: \u0026lt;span\u0026gt;Cascading\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Style\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Sheets\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; 对应树形结构为：\nP ├─ \u0026#34;Let\u0026#39;s use:\u0026#34; ├─ SPAN | └─ \u0026#34;Cascading\u0026#34; ├─ SPAN | └─ \u0026#34;Style\u0026#34; └─ SPAN └─ \u0026#34;Sheets\u0026#34; 当浏览器遇到无法解析的 CSS 代码会发生什么 浏览器什么也不会做，继续解析下一个 CSS 样式。\n相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个 CSS 选择器。\n因此，当为一个元素指定多个 CSS 样式的时候，浏览器会加载样式表中的最后的 CSS 代码进行渲染，正因为如此，可以为同一个元素指定多个 CSS 样式来解决有些浏览器不兼容新特性的问题。\n5. 层叠与继承 冲突规则 层叠 当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n优先级 内联 \u0026gt; id \u0026gt; class \u0026gt; tag\n继承 一些设置在父元素上的 css 属性是可以被子元素继承的，有些则不能。\n例如 color 会继承，但 width 不会继承。因为如果复元素的 width 是50%，后代继承 width，那 CSS 就会很难使用了！\n控制继承 CSS 为控制继承提供了四个特殊的通用属性值。每个 css 属性都接收这些值。\ninherit：使该元素属性和父元素相同。即：开启继承。\ninitial：设置为元素属性的初始默认值，默认值由官方 CSS 规范定义。如果没有默认值且该属性是自然继承的，那么会设置为 inherit。\nunset：重置为自然值，即：如果属性是自然继承那么就是 inherit，否则和 initial 一样。\nrevert: 使该元素样式还原成样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置，否则，按浏览器定义样式表中的样式设置，否则，等价于 unset。\n 通俗解释就是：\n 设置了 inherit 就是继承来自祖上的东西。 设置了 initial 就是抛弃祖上的东西另起炉灶从默认值开始，如果没有默认值，就接着继承祖上的东西。 设置了 unset 就是我不发表意见，本来是继承就继承，本来是默认就默认。 设置了 revert 就是推翻一切，从默认样式表重新开始。   重设所有属性值 CSS 的 shorthand 属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(inherit, initial, unset, or revert)。这是一种撤销对样式所作更改的简便方法，以便回到之前已知的起点。\n.fix-this { all: unset; } ","date":"2021-05-16","permalink":"https://splwany.github.io/zh-cn/posts/webnotes/learn_css/","series":["前端"],"tags":["CSS"],"title":"学习CSS"},{"categories":["学习笔记"],"content":"Python的一些使用技巧和有趣的库\n 1. dataclasses  python3.7引入的内置库，实现数据类，可以利用上内置的类型提示\n 使用方法：\nimport dataclasses as dc @dc.dataclass class Person: name: str # 简单说明类型 age: int = 0 # 设置默认值 sex: str = dc.field(default=\u0026#39;male\u0026#39;, repr=False) # 除了默认值，还可通过repr设置是否显示在字符串输出中 # 创建一个Person实例 p1 = Person(\u0026#39;zhangyan\u0026#39;, 25, \u0026#39;female\u0026#39;) print(p1) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;) 还可以通过asdict和astuple将其转换为dict和tuple类型：\nprint(dc.asdict(p1)) # {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(dc.astuple(p1)) # (\u0026#39;zhangyan\u0026#39;, 25, female) dict类型转为dataclass\np2 = {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(Person(**p2)) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;)  2. namedtuple  给元组命名，元组中的每一项也可以命名；\n创建的元组实例内的值是不能更改的，但可以使用_replace()方法更改值后返回一个新的元组；\n也可以当作一行代码定义一个类；\n也可以当作数据类用，但是无法使用内置的类型提示，不如dataclasses。\n 使用方法：\nfrom collections import namedtuple Color = namedtuple(\u0026#39;Color\u0026#39;, \u0026#39;r g b a\u0026#39;, defaults=[1.0]) # \u0026#39;r g b a\u0026#39;还可以写为\u0026#39;r, g, b, a\u0026#39;或[\u0026#39;r\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] red = Color(255, 0, 0) # 红色 green = Color(0, 255, 0) # 绿色 blue = Color(0, 0, 255) # 蓝色 half_blue = Color(0, 0, 255, 0.5) # 透明度为50%的蓝色 print(half_blue) # Color(r=0, g=0, b=255, a=0.5) half_blue = half_blue._replace(g=233) print(half_blue) orange = Color._make([224, 142, 0, 1]) # 使用_make函数通过传入一个可迭代对象来构建实例，设置了默认值的项依旧不能省略 print(orange) print(orange._asdict()) # OrderedDict([(\u0026#39;r\u0026#39;, 224), (\u0026#39;g\u0026#39;, 142), (\u0026#39;b\u0026#39;, 0), (\u0026#39;a\u0026#39;, 1)]) print(tuple(orange)) # (224, 142, 0, 1)  3. threading  实现类似 JavaScript 中的 setimeout 延迟运行的效果\n 使用方法：\nimport threading def settimeout(func, delay, *args, **kwargs): threading.Timer(delay, func, args, kwargs).start() # 隔一秒输出一个 i，依次为 0 1 2 3 4 for i in range(5): settimeout(lambda x: print(x), i + 1, i) # 隔一秒输出一个 i，依次为 4 4 4 4 4 for i in range(5): settimeout(lambda x: print(i), i + 1, i) # 一秒后一起输出，依次为 44444 for i in range(5): settimeout(lambda x: print(i, end=\u0026#39;\u0026#39;), 1, i) # 一秒后一起输出，顺序随机，例如：43201、12340 for i in range(5): settimeout(lambda x: print(x, end=\u0026#39;\u0026#39;), 1, i)  4. logging  实现日志功能，可以设置显示级别以及保存到日志文件\n 使用方法：\nimport logging # 配置logging默认参数 logging.basicConfig(level=logging.DEBUG, format=\u0026#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s\u0026#39;) # 获取logger logger = logging.getLogger(__name__) # 设置logger级别，级别顺序：DEBUG -\u0026gt; INFO -\u0026gt; WARNING -\u0026gt; ERROR logger.setLevel(level=logging.DEBUG) # 获取保存日志文件的handler handler = logging.FileHandler(\u0026#39;log.txt\u0026#39;) # 设置handler级别 handler.setLevel(logging.INFO) # 获取formatter formatter = logging.Formatter(\u0026#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s\u0026#39;) # 给handler设置formatter handler.setFormatter(formatter) # 给logger添加handler logger.addHandler(handler) # 执行一些测试 logger.info(\u0026#39;start print log\u0026#39;) logger.debug(\u0026#39;do something\u0026#39;) logger.warning(\u0026#39;something maybe fail\u0026#39;) logger.info(\u0026#39;finish\u0026#39;) ","date":"2021-05-12","permalink":"https://splwany.github.io/zh-cn/posts/pythons/python_tips/","series":["python"],"tags":["dataclasses","namedtuple","threading","logging"],"title":"Python小贴士"},{"categories":["待办"],"content":"面试大厂需要了解的知识点\n1. Webpack VS Vite 原理   谈谈 AST 语法树？ 谈谈 babel 的作用？ 如何收集代码依赖？ ES Module 与 CMD 区别？   如何搞懂 webpack 原理呢？手写一个 mini-webpack 是非常直接的方法，比去看原理解析文章效率高多了。\r\r需要做的有：\n 造个轮子 - 手写 Webpack 什么是抽象语法树（AST） 如何分析模块的依赖关系 如何将 ES6 转换为 ES5 读懂 bundle 文件中的天书代码 谁会是下一个 Webpack ","date":"2021-05-06","permalink":"https://splwany.github.io/zh-cn/posts/webnotes/questions/","series":["前端"],"tags":["面试问题"],"title":"待学习的知识"},{"categories":["学习笔记"],"content":"MDN文档的HTML学习笔记\n 1. 嵌入 \u0026lt;iframe\u0026gt; 元素\r sandbox属性 该属性需要在已经支持其他\u0026lt;iframe\u0026gt;功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置。\r\r注意：为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的src属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间。\r\r\u0026lt;embed\u0026gt; 和 \u0026lt;object\u0026gt; 元素\r 这两个元素与\u0026lt;iframe\u0026gt;不同，是用来嵌入多种类型的外部内容的通用嵌入工具，包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容。\n插件是一种对浏览器原生无法读取的内容提供访问权限的软件\r\r 2. 矢量图形SVG\r 快捷方式：\u0026lt;img\u0026gt; 使用 src 属性设置SVG路径\n疑难解答和跨浏览器支持 对于不支持SVG（IE 8及更低版本，Android 2.3 及更低版本）的浏览器，可以从 src 属性引用 PNG 或 JPG ，并使用 srcset 属性 只有最近的浏览器才能识别）来引用 SVG 。 在这种情况下，仅支持浏览器将加载 SVG - 较旧的浏览器将加载 PNG ：\n\u0026lt;img src=\u0026#34;equilateral.png\u0026#34; alt=\u0026#34;triangle with equal sides\u0026#34; srcset=\u0026#34;equilateral.svg\u0026#34;\u0026gt; 还可以使用 SVG 作为 CSS 背景图像，如下所示。 在下面的代码中，旧版浏览器会坚持他们理解的 PNG ，而较新的浏览器将加载 SVG ：\n.svg { background: url(\u0026#34;fallback.png\u0026#34;) no-repeat center; background-image: url(\u0026#34;image.svg\u0026#34;); background-size: contain; } 像上面描述的\u0026lt;img\u0026gt;方法一样，使用 CSS 背景图像插入 SVG 意味着它不能被 JavaScript 操作，并且也受到相同的 CSS 限制。\n在HTML中引入SVG代码  可以在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中 - 这有时称为将SVG内联或内联SVG。确保您的SVG代码在\u0026lt;svg\u0026gt;\u0026lt;/svg\u0026gt;标签中（不要在外面添加任何内容）。\n \u0026lt;svg width=\u0026#34;300\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; fill=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; 优点  将 SVG 内联减少 HTTP 请求，可以减少加载时间。 可以为 SVG 元素分配class和id，并使用 CSS 修改样式。 内联 SVG 是唯一可以在 SVG 图像上使用 CSS 交互（如:focus）和 CSS 动画的方法（即使在常规样式表中）。 可以通过将 SVG 标记包在 \u0026lt;a\u0026gt; 元素中，使其成为超链接。  缺点  这种方法只适用于在一个地方使用的 SVG 。多次使用会导致资源密集型维护（resource-intensive maintenance）。 额外的 SVG 代码会增加 HTML 文件的大小。 浏览器不能像缓存普通图片一样缓存内联 SVG 。 可能会在 \u0026lt;foreignObject\u0026gt; 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。考虑一下仅仅为支持过时的浏览器，而增加额外开销是否真的值得。  示例 遁入智瞳！上勾拳！     3. 响应式图片  目的：学习如何使用 srcset 以及 \u0026lt;picture\u0026gt; 元素，来实现网页中的响应式图片处理方法。\n 新特性 srcset / sizes / \u0026lt;picture\u0026gt; —— 都已经被新版本的现代浏览器和移动浏览器支持。\r\r 分辨率切换：不同的尺寸 两个新属性：srcset 和 sizes 提供额外的资源图像和提示。\n  浏览器根据设备宽度到 sizes 中找到不超过 max-width 的那一项 根据此项后面的像素值 a，到 srcset 中找到不小于这个值的最接近的 b 将 srcset 对应的图片路径作为需要显示的图片路径，以达到省流目的   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/water-320w.jpg 320w, /images/posts/webnotes/learn_html/water-480w.jpg 480w, /images/posts/webnotes/learn_html/water-800w.jpg 800w, /images/posts/webnotes/learn_html/water-1280w.jpg 1280w\u0026#34; sizes = \u0026#34;(max-width: 424px) 320px, (max-width: 767px) 460px, (max-width: 991px) 800px, 1280px\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/water-1280w.jpg\u0026#34; alt=\u0026#34;Drink more water\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕大小下载合适的图片，来省流。\r\r 分辨率切换：相同的尺寸，不同的分辨率 如果想支持多分辨率显示，但希望每个人在屏幕上看到的图片的实际尺寸是相同的，使用 srcset 和 x 语法结合——一种更简单的语法——而不用 sizes ，来选择适当分辨率的图片。\n  浏览器根据设备的 DPR（即设备像素比），从 srcset 中找到像素比最接近的图片路径 将此路径的图片显示出来，图片的大小由 CSS 样式表中的 width 值来定义 浏览器会保证图片在任何设备上的物理大小一致   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png, /images/posts/webnotes/learn_html/mercy-480w.png 1.5x, /images/posts/webnotes/learn_html/mercy-800w.png 2.5x, /images/posts/webnotes/learn_html/mercy-1280w.png 4x\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34; style=\u0026#34;width: 180px;\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕像素密度来决定使用哪个版本的图片，并根据 `width` 的值保证图片在所有设备上实际大小一致。\r\r 美术设计  使用 \u0026lt;picture\u0026gt; 元素实现当屏幕缩小时动态得使用对应像素的图片，将内容适应小屏幕观看，例如人物更大的低分辨率图片。\n \u0026lt;picture\u0026gt; \u0026lt;!-- 小手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 424px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png\u0026#34;\u0026gt; \u0026lt;!-- 大手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 767px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-480w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑竖屏 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 991px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-800w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑横屏 / 笔记本电脑 --\u0026gt; \u0026lt;source srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.jpg\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 效果（调整浏览器宽度以查看变化）：\n   应该仅仅在美术设计场景下使用media属性；当使用media时，不要在sizes属性中也提供媒体条件。\r\r 为什么不能使用 CSS 或 JavaScript 来做到这一效果？ 如果使用CSS或JavaScript来实现这一效果，在这之前原始图像已经被加载了，然后CSS或JavaScript又加载了一个小的图像，反而浪费发了流量。\n 大胆使用现代图像格式 新图像格式（例如 WebP 和 JPEG-2000）可以在有高质量的同时有较低的文件大小。但是浏览器支持情况不同。\n可以使用 \u0026lt;picture\u0026gt; 来继续满足老式浏览器的需要。可以在 type 属性中提供 MIME 类型，这样浏览器就能立即拒绝不支持的类型：\n\u0026lt;picture\u0026gt; \u0026lt;source type=\u0026#34;image/svg+xml\u0026#34; srcset=\u0026#34;***.svg\u0026#34;\u0026gt; \u0026lt;source type=\u0026#34;image/webp\u0026#34; srcset=\u0026#34;***.webp\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;***.png\u0026#34; alt=\u0026#34;example image\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt;  不要使用 media 属性，除非需要美术设计。 在 \u0026lt;source\u0026gt; 元素中，只可以引用在 type 中声明的文件类型。 如果必要，可以在 srcset 和 sizes 中使用逗号分割的列表。 ","date":"2021-05-05","permalink":"https://splwany.github.io/zh-cn/posts/webnotes/learn_html/","series":["前端"],"tags":["HTML"],"title":"学习HTML"},{"categories":["Shortcode"],"content":"本文展示了如果使用 alert shortcode。\n{{\u0026lt; alert \u0026#34;Message\u0026#34; [type] \u0026gt;}}  The parameter type is optional. Default to info.\n Info {{\u0026lt; alert \u0026#34;Info\u0026#34; \u0026gt;}} Info\r\rSuccess {{\u0026lt; alert \u0026#34;Success\u0026#34; success \u0026gt;}} Success\r\rWarning {{\u0026lt; alert \u0026#34;Warning\u0026#34; warning \u0026gt;}} Warning\r\rDanger {{\u0026lt; alert \u0026#34;Danger\u0026#34; danger \u0026gt;}} Danger\r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/alert/","series":["用户手册"],"tags":["Alert"],"title":"Alert Shortcode"},{"categories":["Shortcode"],"content":"关于哔哩哔哩 shortcode 的详细使用说明。\n使用 {{\u0026lt; bilibili \u0026#34;video id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/bilibili/","series":null,"tags":["哔哩哔哩"],"title":"Bilibili Shortcode"},{"categories":["Shortcode"],"content":"关于 CodePen shortcode 的详细说明。\n使用 {{\u0026lt; codepen \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/codepen/","series":null,"tags":["CodePen"],"title":"CodePen Shortcode"},{"categories":["Shortcode"],"content":"关于 JSFiddle shortcode 的详细说明。\n使用 {{\u0026lt; jsfiddle \u0026#34;user/id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/jsfiddle/","series":null,"tags":["JSFiddle"],"title":"JSFiddle Shortcode"},{"categories":["Shortcode"],"content":"关于 JSRun shortcode 的详细说明。\n使用 {{\u0026lt; jsrun \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/jsrun/","series":null,"tags":["JSRun"],"title":"JSRun Shortcode"},{"categories":["Shortcode"],"content":"关于优酷 shortcode 的详细说明。\n使用 {{\u0026lt; youku \u0026#34;XNTQwMTgxMTE2\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/youku/","series":null,"tags":["Youku"],"title":"优酷 Shortcode"},{"categories":["Shortcode"],"content":"关于爱奇艺 shortcode 的详细说明。\n使用 {{\u0026lt; iqiyi \u0026#34;vid\u0026#34; \u0026#34;tvid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/iqiyi/","series":null,"tags":["爱奇艺"],"title":"爱奇艺 Shortcode"},{"categories":["Shortcode"],"content":"关于网易云音乐 Shortcode 的详细使用说明。\n使用 {{\u0026lt; neteasemusic \u0026#34;id\u0026#34; [auto [type]] \u0026gt;}}    Parameter Description     auto The auto controls whether to autoplay. Boolean and optional, default to false.   type The type parameter is optional. Default to 2.    例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/neteasemusic/","series":null,"tags":["网易云音乐"],"title":"网易云音乐 Shortcode"},{"categories":["Shortcode"],"content":"关于腾讯视频 shortcode 的详细说明。\n使用 {{\u0026lt; tencentvideo \u0026#34;vid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"https://splwany.github.io/zh-cn/posts/shortcodes/tencentvideo/","series":null,"tags":["腾讯视频"],"title":"腾讯视频 Shortcode"}]