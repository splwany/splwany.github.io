[{"categories":["学习笔记"],"content":"使用deviceorientation事件获取手机重力参数\n   if (window.DeviceOrientationEvent) { const targetDiv = document.querySelector('#demo span'); window.addEventListener('deviceorientation', e = { console.log(e); const {alpha, beta, gamma} = e; targetDiv.textContent = `x: ${beta} y: ${gamma} z: ${alpha}`; }); } ","date":"2021-07-21","permalink":"/zh-cn/posts/webnotes/orientation/","series":["前端"],"tags":["deviceorientation"],"title":"网页重力感应"},{"categories":["学习笔记"],"content":"Javascript中的各种垃圾回收机制\n前言 垃圾回收器是一把十足的双刃剑。其好处是可以大幅简化程序的内存管理代码，因为内存管理无需程序员来操作，由此也减少了（但没有根除）长时间运转的程序的内存泄漏。对于某些程序员来说，它甚至能够提升代码的性能。\n另一方面，选择垃圾回收器也就意味着程序当中无法完全掌控内存，而这正是移动终端开发的症结。对于JavaScript，程序中没有任何内存管理的可能——ECMAScript标准中没有暴露任何垃圾回收器的接口。网页应用既没有办法管理内存，也没办法给垃圾回收器进行提示。\nnodeJs查看垃圾回收日志的方式主要是在启动时添加 --trace_gc 参数。\n关于垃圾回收 垃圾回收器要解决的最基本问题就是，辨别需要回收的内存。一旦辨别完毕，这些内存区域即可在未来的分配中重用，或者是返还给操作系统。一个对象当它不是处于活跃状态的时候它就死了（废话）。一个对象处于活跃状态，当且仅当它被一个根对象或另一个活跃对象指向。根对象被定义为处于活跃状态，是浏览器或V8所引用的对象。比如说，被局部变量所指向的对象属于根对象，因为它们的栈被视为根对象；全局对象属于根对象，因为它们始终可被访问；浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下它们只是弱引用。\n从侧面来说，上面的定义非常宽松。实际上我们可以说，当一个对象可被程序引用时，它就是活跃的。比如：\nfunction f() { var obj = {x: 12}; g(); // 可能包含一个死循环  return obj.x; } 这里的obj.x和obj都是活跃的，尽管对其的再度引用是在死循环之后。\n很遗憾，我们无法精确地解决这个问题，因为这个问题实际等价于停机问题，无法确定。因此我们做一个等价约定：如果一个对象可经由某个被定义为活跃对象的对象，通过某个指针链所访问，则它就是活跃的。其他的都被视为垃圾。\n垃圾回收过程\r 垃圾回收机制有多种，但最常用的就是以下几种：\n\r 分代回收 在V8中所有的JavaScript对象都是通过堆来分配的。为了提高垃圾回收的效率，V8将堆分为新生代和老生代两个部分，其中新生代为存活时间较短的对象(需要经常进行垃圾回收)，而老生代为存活时间较长的对象(垃圾回收的频率较低)，如图：\n\r 新生代 新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 Cheney 算法。\n Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置中。处于使用中的 semispace 空间成为 From 空间，处于闲置状态的空间成为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将被释放。完成复制后， From 空间和 To 空间的角色发生对换。\n Scavenge 的缺点是只能使用堆内存的一半，但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上表现优异。Scavenge 是典型的牺牲空间换取时间的算法，无法大规模地应用到所有的垃圾回收中，但非常适合应用在新生代中。\n\r 对象是如何释放的呢？ 有个叫可达性分析算法的概念，即通过一系列的称为“GC ROOT”的对象作为起始点。从这些节点开始向下搜索。搜索走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链时，则证明此对象是不可用的。当然在虚拟机判断要被释放的对象里面，即使在可达性分析算法中不可达的对象，也并非是立即释放的。如果对象在进行可达性分析后发现没有与GC ROOTS相连接的引用链。将会对它进行一次标记，并进行刷选。它会放进一个队列中依次进行回收。如果这时又有对象引用到它，它就不会被回收。\n晋升 对象从新生代中移动到老生代中的过程称为晋升。\nFrom 空间中的存活对象在复制到 To 空间之前需要进行检查，在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象的晋升。\n晋升条件主要有两个：\n 对象是否经历过一次 Scavenge 回收，是的话，则移动到老生代 To 空间已经使用超过 25%，To 空间对象移动到老生代  设置 25% 这个限制值得原因是当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配。\n写屏障 上面有一个细节被忽略了：如果新生区中某个对象，只有一个指向它的指针，而这个指针恰好是在老生区的对象当中，我们如何才能知道新生区中那个对象是活跃的呢？显然我们并不希望将老生区再遍历一次，因为老生区中的对象很多，这样做一次消耗太大。\n为了解决这个问题，实际上在写缓冲区中有一个列表(我们称之为CrossRefList)，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障——因为每个写操作都要经历这样一关。\n\r 老生代 老生代的内存空间较大且存活对象较多，因此其垃圾回收算法也就没有新生代那么简单了。为此V8使用了标记-清除算法 (Mark-Sweep)进行垃圾回收，并使用标记-压缩算法 (Mark-Compact)整理内存碎片，提高内存的利用率。老生代的垃圾回收算法步骤如下：\n1. 对老生代进行第一遍扫描，标记存活的对象 2. 对老生代进行第二次扫描，清除未被标记的对象 3. 将存活对象往内存的一端移动 4. 清除掉存活对象边界外的内存 Mark-Sweep Mark-Sweep 是标记清除的意思，它分为两个阶段，标记和清理。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除未被标记的对象。\n\r 算法机制\n在标记阶段，所有堆上的活跃对象都会被标记。每个页（注意，V8的内存页是1MB的连续内存块，与虚拟内存页不同）都会包含一个用来标记的位图，位图中的每一位对应页中的一字。这个标记非常有必要，因为指针可能会在任何字对齐的地方出现。显然，这样的位图要占据一定的空间（32位系统上占据3.1%，64位系统上占据1.6%），但所有的内存管理机制都需要这样占用，因此这种做法并不过分。除此之外，另有2位来表示标记对象的状态。由于对象至少有2字长，因此这些位不会重叠。\n状态一共有三种：如果一个对象的状态为白，那么它尚未被垃圾回收器发现；如果一个对象的状态为灰，那么它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕；如果一个对象的状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕。\n如果将堆中的对象看作由指针相互联系的有向图，标记算法的核心实际是深度优先搜索。在标记的初期，位图是空的，所有对象也都是白的。从根可达的对象会被染色为灰色，并被放入标记用的一个单独分配的双端队列。标记阶段的每次循环，GC会将一个对象从双端队列中取出，染色为黑，然后将它的邻接对象染色为灰，并把邻接对象放入双端队列。这一过程在双端队列为空且所有对象都变黑时结束。\n特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。\n标记算法结束时，所有的活跃对象都被染为了黑色，而所有的死对象则仍是白的。这一结果正是清理和紧缩两个阶段所期望的。\n类似三色标记法大致如图：\n第一步：\n\r 第二步：\n\r 第三步：\n\r 清理阶段，清理算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。每一页都包含数个空闲内存链表，其分别代表小内存区（\u0026lt;256字）、中内存区（\u0026lt;2048字）、大内存区（\u0026lt;16384字）和超大内存区（其它更大的内存）。\n清理算法非常简单，只需遍历页的位图，搜索连续的白对象。空闲内存链表大量被scavenge算法用于分配存活下来的活跃对象，但也被紧缩算法用于移动对象。有些类型的对象只能被分配在老生区，因此空闲内存链表也被它们使用。\nMark-Compact Mark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。\n为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在 Mark-Sweep的基础上演进而来的。它们的差别在于对象在标记为死亡后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\r 算法机制\n紧缩算法会尝试将对象从碎片页（包含大量小空闲内存的页）中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就可以返还给操作系统了。\n迁移整合的过程非常复杂，大概过程是这样的。对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址。迁出过程中，对象中的旧地址会被记录下来，这样在迁出结束后V8会遍历它所记录的地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。注意，如果一个页非常“活跃”，比如其中有过多需要记录的指针，则地址记录会跳过它，等到下一轮垃圾回收再进行处理。\n全停顿 下表为3种主要垃圾回收算法的简单比较：\n\r 在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以从新生代中晋升过来的对象进行分配时才使用 Mark-Compact 。为了避免出现 JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种算法都需要将应用逻辑暂停下来，这种行为称为“全停顿” (stop-the-world)。\n由于新生代配置的空间较小，存活对象较少，全停顿对新生代影响不大。但老生代通常配置的空间较大，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清除、整理等动作造成的停顿就会比较可怕。\n增量标记与惰性清理 增量标记 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改成增量标记(Incremental Marking)，也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收和应用逻辑交替执行直到标记阶段完成。\n增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。\n但增量标记和普通标记不同的是，对象的图谱关系可能发生变化！我们需要特别注意的是，那些从黑对象指向白对象的新指针。回忆一下，黑对象表示其已完全被垃圾回收器扫描，并不会再进行二次扫描。因此如果有“黑→白”这样的指针出现，我们就有可能将那个白对象漏掉，错当死对象处理掉。（标记过程结束后剩余的白对象都被认为是死对象。）于是我们不得不再度启用写屏障。现在写屏障不仅记录“老→新”指针，同时还要记录“黑→白”指针。一旦发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。\n惰性清理 增量标记完成后，惰性清理就开始了。所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。\n在两段的GC程序之间，引用关系可能发生了变化。所以，这种GC算法也要写屏障，来记录引用关系的变化。虽然这种方式控制了中断最高时间，但是由于中断次数增加，GC总时间是增加的。\n\r 并发标记 并发式 GC（concurrent），即在垃圾回收的同时不需要停止程序的运行，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，所以也要进行写屏障操作。\n一般能在垃圾回收的过程中修改对象的存在，不管是垃圾回收器本身还是运行时，或者是正在执行的程序，都统称为 mutator（翻译不详）。\n增量标记和并发标记对程序执行更宽松的GC，都需要运行时从整体设计上保证mutator不会在垃圾回收的过程中与垃圾回收器同时修改对象，造成无法预料的后果。比如清洁阿姨打扫一个房间的时候可以把房间的门先关上，这样熊孩子就进不来了，但熊孩子们依然可以在屋子里的其他地方活动。在程序运行的同时进行垃圾回收虽然可能导致垃圾回收的周期变长（即降低了垃圾回收单位时间内的吞吐量），但是可以降低每次暂停的时间，进而提高程序的响应效率。\n然而这种方式也并未做到完全不暂停原程序的运行，在某些特定的GC阶段还是要暂停原程序。\n\r 准确式 GC (Accurate GC) 虽然 ECMA 中没有规定整数类型，Number 都是 IEEE 浮点数，但是由于在 CPU 上浮点数相关的操作通常比整型操作要慢，大多数的 Javascript 引擎都在底层实现中引入了整型，用于提升for循环和数组索引等场景的性能，并配以一定的技巧来将指针和整数（可能还有浮点数）“压缩”到同一种数据结构中节省空间。\n在 V8 中，对象都按照 4 字节（32 位机器）或者 8 字节（64 位机器）对齐，因此对象的地址都能被 4 或者 8 整除，这意味着地址的二进制表示最后 2 位或者 3 位都会是 0，也就是说所有指针的这几位是可以空出来使用的。如果将另一种类型的数据的最后一位也保留出来另作他用，就可以通过判断最后一位是 0 还是 1，来直接分辨两种类型。那么，这另一种类型的数据就可以直接塞在前面几位，而不需要沿着一个指针去读取它的实际内容。在 V8 的语境内这种结构叫做小整数（SMI, small integer），这是语言实现中历史悠久的常用技巧 tagging 的一种。V8 预留所有的字（word，32位机器是 4 字节，64 位机器是8字节）的最后一位用于标记（tag）这个字中的内容的类型，1 表示指针，0 表示整数，这样给定一个内存中的字，它能通过查看最后一位快速地判断它包含的指针还是整数，并且可以将整数直接存储在字中，无需先通过一个指针间接引用过来，节省空间。\n由于 V8 能够通过查看字的最后一位，快速地分辨指针和整数，在GC的时候，V8能够跳过所有的整数，更快地沿着指针扫描堆中的对象。由于在 GC 的过程中，V8 能够准确地分辨它所遍历到的每一块内存的内容属于什么类型，因此V8的垃圾回收器是准确式的。与此相对的是保守式 GC，即垃圾回收器因为某些设计导致无法确定内存中内容的类型，只能保守地先假设它们都是指针然后再加以验证，以免误回收不该回收的内存，因此可能误将数据当作指针，进而误以为一些对象仍然被引用，无法回收而浪费内存。同时因为保守式的垃圾回收器没有十足的把握区分指针和数据，也就不能确保自己能安全地修改指针，无法使用那些需要移动对象，更新指针的算法。\n\r 准确式的 GC 避免了保守式 GC 带来的弊端，能够尽早无遗漏地回收内存，并且能够在GC过程中移动对象以缓解内存碎片问题。\n查看原文\r","date":"2021-07-03","permalink":"/zh-cn/posts/javascripts/js_gc/","series":["前端"],"tags":["Javascript","nodejs","垃圾回收"],"title":"详细讲解node/v8/js垃圾回收机制"},{"categories":["学习笔记"],"content":"根据一个数组（前序遍历、层次遍历）创建一个二叉树，并显示二叉树的左右视图。\n尝试使用函数式编程，不使用class。\n1. 定义二叉树节点 function BuildBiTreeNode(value = null, left = null, right = null) { return { value, left, right }; } 2. 设置表示二叉树的两种Array（前序遍历、层序遍历） 假设有一个二叉树可以用以下两种Array来表示：\n// pre 前序遍历 const input = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;10\u0026#39;]; // level 层序遍历 const input = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;10\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;9\u0026#39;]; 二叉树如图所示：\n二叉树示例\r 3. 定义MODE枚举 const MODE = { PRE: 0, // 前序表示法  LEVEL: 1 // 层序表示法 }; 4. 利用函数科里化对不同MODE返回不同构建二叉树的方法 function traverse(mode, flag) { if (!Object.values(MODE).includes(mode)) throw TypeError(\u0026#39;mode必须是BuildBiTree.MODE类型\u0026#39;); const _pre = arr =\u0026gt; { if (arr.length === 0) return; const value = arr.pop(); if (value === flag) return null; const node = BuildBiTreeNode(value); node.left = _pre(arr); node.right = _pre(arr); return node; }; const _level = (arr) =\u0026gt; { if (arr.length === 0) return; let value = arr.pop(); let node = BuildBiTreeNode(value); const root = node; const level_arr = [node]; while (level_arr.length \u0026gt; 0) { const curNode = level_arr.shift(); value = arr.pop(); if (value !== flag) { if (typeof value === \u0026#39;undefined\u0026#39;) break; node = BuildBiTreeNode(value); curNode.left = node; level_arr.push(node); } value = arr.pop(); if (value !== flag) { if (typeof value === \u0026#39;undefined\u0026#39;) break; node = BuildBiTreeNode(value); curNode.right = node; level_arr.push(node); } } return root; }; return { [MODE.PRE]: _pre, [MODE.LEVEL]: _level }[mode]; } 5. 构建二叉树，并返回一个包含二叉树、左视图方法、右视图方法的对象 function BuildBiTree(input_array, mode=MODE.PRE, flag=\u0026#39;#\u0026#39;) { if (typeof flag !== \u0026#39;string\u0026#39;) throw TypeError(\u0026#39;flag必须是string类型\u0026#39;); if (!Array.isArray(input_array) || input_array.length === 0) return null; const fn = traverse(mode, flag); let tree = fn(input_array.slice().reverse()); tree.toJson = function(space) { return JSON.stringify(this, undefined, space); }; const _leftView = (root, level, viewArr) =\u0026gt; { if (!root) return; if (level === viewArr.length) viewArr.push(root.value); _leftView(root.left, level + 1, viewArr); _leftView(root.right, level + 1, viewArr); }; const _rightView = (root, level, viewArr) =\u0026gt; { if (!root) return; if (level === viewArr.length) viewArr.push(root.value); _rightView(root.right, level + 1, viewArr); _rightView(root.left, level + 1, viewArr); }; return { tree, leftView() { const viewArr = []; _leftView(this.tree, 0, viewArr); return viewArr; }, rightView() { const viewArr = []; _rightView(this.tree, 0, viewArr); return viewArr; } }; } BuildBiTree.MODE = MODE; 6. 测试效果 const input = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;10\u0026#39;]; // pre 前序遍历 // const input = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;10\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;9\u0026#39;]; // level 层序遍历 const myTree = BuildBiTree(input, BuildBiTree.MODE.PRE, \u0026#39;#\u0026#39;); console.log(\u0026#39;tree: \u0026#39;, myTree.tree.toJson(2)); console.log(\u0026#39;left view: \u0026#39;, myTree.leftView()); console.log(\u0026#39;right view: \u0026#39;, myTree.rightView()); ","date":"2021-07-03","permalink":"/zh-cn/posts/javascripts/bi_tree_leftrightview/","series":["算法"],"tags":["JavaScript","二叉树"],"title":"二叉树的创建及左右视图"},{"categories":["学习笔记"],"content":"YOLOV5模型部署到Android的过程记录，系统环境：Ubuntu\n 1. PyTorch模型转ONNX 1.1 进入yolov5根目录，执行如下命令 cd path/to/yolov5 python models/export.py --weights runs/train/exp/weights/best.pt --train --include onnx 其中第二行命令中的--weights指保存的参数文件；\n--train表示模型以train模式进行，主要是根据yolov5的代码来看，需要导出train模式的网络结构，因为forward需要return三个输出，如果是eval模式，输出的不是这种格式；\n--include表示需要导出的目标格式有哪些，因为目前只需要onnx，所以需要只写onnx，默认导出各种支持的格式\n1.2 进入onnx文件所在目录，简化onnx cd path/to/yolov5/runs/train/exp/weights python -m onnxsim best.onnx best-sim.onnx 其中模块onnxsim是需要下载的，使用pip install onnx-simplifier； 安装完onnx-simplifier后即可使用如上命令来简化onnx文件，得到best-sim.onnx；\n2. ONNX转NCNN 2.1 下载ncnn预编译版本 可以到github下载ncnn源码\r并自行编译，本文只讲预编译版本\r的使用。\n我的环境是Ubuntu16，所以下载的是ncnn-20210525-ubuntu-1604-shared.zip\r。目前不清楚shared版和无shared版的区别，不过貌似不带shared的版本缺一些东西导致报错。\n将压缩文件解压后即可使用ncnn了。\n2.2 进入onnx文件所在目录，并转化为ncnn的param文件和bin文件 cd path/to/yolov5/runs/train/exp/weights path/to/ncnn/bin/onnx2ncnn best-sim.onnx yolov5s-traffic.param yolov5s-traffic.bin 不出所料，转化完成，但是出现如下报错：\n转换过程中有一些不支持的结构\r 此时需要手动修改生成的param文件来解决错误。\n2.3 修改param文件中的内容来更改网络结构 下图为param文件修改前的情况：\n修改前的内容\r 转换错误的层为5到12行的Crop操作，因此需要将4到13行全部删除并体会为自定义层YoloV5Focus。因为一共减少了9层，所以将第2行的第1个值减9：\n换为自定义层后的内容\r 另外，网络最后有三个reshape层，我们需要实现输入任意尺寸的图片，因此需要将位置0的大小改为-1以实现自动计算大小：\n修改reshape层的内容\r 2.4 优化param文件和bin文件 path/to/ncnn/bin/ncnnoptimize yolov5s-traffic.param yolov5s-traffic.bin yolov5s-traffic-opt.param yolov5s-traffic-opt.bin 1 其中末尾的1表示将float32优化为float16以降低文件大小。\n","date":"2021-06-21","permalink":"/zh-cn/posts/pythons/pytorch_to_android/","series":["deep learning"],"tags":["pytorch","yolov5","android","onnx","ncnn"],"title":"PyTorch模型部署到Android"},{"categories":["学习笔记"],"content":"深度学习超强大的一款可视化工具\n 1. 安装 pip install wandb 2. 使用 import wandb # 使用自己的 W\u0026amp;B 账号登录 wandb.login() # 开启一个新的 run 来追踪 wandb.init( # 指定项目名称 project=\u0026#34;basic-intro\u0026#34;, # 跟踪超参数并运行元数据 config={ \u0026#34;learning_rate\u0026#34;: 0.02, \u0026#34;architecture\u0026#34;: \u0026#34;CNN\u0026#34;, \u0026#34;dataset\u0026#34;: \u0026#34;CIFAR-100\u0026#34;, } ) # 在需要显示的地方使用如下方式 wandb.log({ \u0026#34;acc\u0026#34;: acc, \u0026#34;loss\u0026#34;: loss, }) # 结束 wandb.finish() 官方文档\r","date":"2021-06-02","permalink":"/zh-cn/posts/pythons/weights_and_biases/","series":["deep learning"],"tags":["wandb"],"title":"Weights \u0026 Biases 深度学习可视化工具"},{"categories":["学习笔记"],"content":"JavaScript中的继承、原型、原型链，以及类的创建\n1. 继承  JavaScript中有6种继承方式：基本继承、借用构造函数、组合继承、原型式继承、寄生式继承、寄生组合式继承\n 1.1 基本继承 function Parent() {} Parent.prototype.method1() {} function Child() {} Child.prototype = new Parent() Child.prototype.constructor = Child 即通过将Parent的一个实例直接作为子类Child的原型对象，所有Child实例都通过__proto__指向这个Parent实例。\n弊端：\n  原型对象中的所有引用类型的值会被子类共享\n  无法在构造子类的时候向父类的构造函数动态传值\n  因此，这种继承方式几乎很少单独使用，但当父类只是定义了一些方法时，仍然可以使用该方式。\n1.2 借用构造函数 function Parent(name, age) { this.name = name this.age = age } // 使用new来创建一个示例 const parent = new Parent(\u0026#39;Alan Wei\u0026#39;, 26) // new的实现原理类似如下函数 function newObj(constructor, ...args) { const tmp = {} tmp.__proto__ = constructor.prototype constructor.call(tmp, ...args) return tmp } const parent2 = newObj(Parent, \u0026#39;Alan Wei\u0026#39;, 26) 思考一下，既然构造函数可以用来构造空对象，为什么不能用来构造子类实例呢？比如：\nfunction Child(name, age) { Parent.call(this, name, age) } const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 此时，我们“借用”了Parent的构造函数作为构造规则，为Child创建了实例（使用new调用Child时，内部的this就是一个Child实例）。现在我们在Parent构造函数中定义的所有属性和方法都会给当前Child实例重新定义一遍，从而实现了继承。\n解决了第一种继承方式的两大弊端：\n  引用类型属性的共享。现在每个子类实例的属性都是借用父类构造函数新定义的，因此相互独立。\n  无法向父类构造函数动态传值。现在向Child传入的参数又被传给了父类构造函数，因此该问题也得到了解决。\n  缺点：\n父类的所有属性和方法都需要重新构造一遍，导致方法无法被共享，每个子类都需要维护一个相同的方法，失去了继承的本质。\n因此，我们可以考虑融合上面两种方法的优点，创造一种更好的继承方式。\n1.3 组合继承 组合使用上述两种继承方式，来实现方法的共享和属性的独立构造。通用习惯就是，把属性放在父类的构造函数中，把方法放在父类的原型上。\nfunction Child(name, age) { Parent.call(this, name, age) } Child.prototype = new Parent() // Child中定义自己的constructor指向，否则会自动通过原型链使用父类原型对象上的constructor Child.constructor = Child 但这种方式并非完美，实际上需要调用父类构造函数两次：\nfunction Child(name, age) { Parent.call(this, name, age) // 第二次调用Parent的构造函数 } Child.prototype = new Parent() // 第一次调用Parent的构造函数 Child.constructor = Child const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 既然子类会有Parent构造出来属性，必然屏蔽Child原型对象上Parent实例属性，那为什么还要浪费时间和内存去构造它呢？为了解决这个问题，又衍生出下面的继承方式。\n1.4 原型式继承 与基本继承的原型式继承的不同之处在于，这是一种更“干净”的实现，它只继承父类的原型，而不继承父类构造函数中的属性（及可能存在的方法）。\nfunction createObj( prototype ) { // 重建一个空构造函数  function F(){} // 将该构造函数的原型链替换为传入的原型对象  F.prototype = prototype // 创建并返回一个空对象，但该对象的__proto__指向传入的prototype  return new F() } // child是个空对象，但可以借助原型链访问Parent的原型属性和方法 const child = createObj(Parent.prototype) 上面这种方式在ES5中得到了原生实现，即Object.create()方法，可以传入一个原型对象进去，构造一个以该原型为原型的空对象，这在某些轻量级的继承场景中是十分便捷的：\nconst child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 26 该继承方式显然有着自己的缺陷，但它却为解决组合继承的重复构造问题提供了思路。在介绍如何通过原型式继承来解决组合继承遇到的问题之前，我们再介绍另外一种继承方式 - 寄生式继承，它是原型式继承的工厂化版本。\n1.5 寄生式继承 在上面的原型式继承中，我们创建了一个空的子类对象之后，需要手动为其添加自有的属性和方法，如：\nconst child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 26 上述三条语句都是用于构造子类对象的，但却是独立的，我们认为这样耦合性较差，封装程度不够，因此我们通常会将其封装为一个函数：\nfunction createChild(Parent) { const child = Object.create(Parent.prototype) child.name = \u0026#39;Alan Wei\u0026#39; child.age = 24 } const child = createChild(Parent) 当我们定义了上述函数之后，每次构造一个子类对象，只需要写下面的一行语句即可，代码看上去也优雅了很多，这就是所谓的寄生式继承。所以，寄生式继承就是原型式继承的一个工厂化（将一系列流程封装在一起，进行快速批量生产）版本。\n显然寄生式继承并不是为了解决原型式继承的问题而存在的。接下来我们就来了解一种更加优雅的继承方式 - 寄生式组合继承。\n1.6 寄生组合式继承 思路：用原型式继承替换组合继承中的基本继承\nfunction Parent(name, age) { this.name = name this.age = age } Parent.prototype.method1 = function() {} function Child(name, age) { Parent.call(this, name, age) } Child.prototype = Object.create(Parent.prototype) Child.prototype.constructor = Child const child = new Child(\u0026#39;Alan Wei\u0026#39;, 26) 目前，寄生组合式继承被认为是JavaScript实现继承的一种比较理想的方式。\n","date":"2021-05-22","permalink":"/zh-cn/posts/javascripts/prototype_chain/","series":["前端"],"tags":["JavaScript","prototype","继承","原型链","ES5","ES6"],"title":"JavaScript继承、原型和原型链"},{"categories":["学习笔记"],"content":"开课吧VUE体验课笔记\n \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{title}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;{{state.title}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 接收obj，代理它，使他成为响应式的  // 替换Object.defineProperty()  function reactive(obj) { // vue3中基于Proxy  return new Proxy(obj, { get(target, key) { console.log(\u0026#39;get\u0026#39;, key) // 依赖收集  track(target, key) return target[key] }, set(target, key, val) { console.log(\u0026#39;set\u0026#39;, key) target[key] = val // update()  // app.update()  // 触发依赖  trigger(target, key) }, }) } // 添加副作用函数  const effectStack = [] // 临时存储fn  function effect(fn) { // 如果fn中用到了响应式数据，当他们发生变化，fn会再次执行，称为副作用函数  const eff = function() { try { effectStack.push(eff) fn() } finally { effectStack.pop() } } // 执行一次，出发依赖收集  eff() return eff } // 依赖收集函数track  // {target: {key: [eff]}}  const targetMap = {} function track(target, key) { // 获取副作用函数  const effect = effectStack[effectStack.length - 1] if (effect) { let map = targetMap[target] if (!map) { map = targetMap[target] = {} } let deps = map[key] if (!deps) { deps = map[key] = [] } // 将副作用函数放入deps  if (deps.indexOf(effect) === -1) { deps.push(effect) } } } function trigger(target, key) { const map = targetMap[target] if (map) { const deps = map[key] if (deps) { deps.forEach(dep =\u0026gt; dep()) } } } function h(tag, props, children) { return {tag, props, children} } // createApp返回应用程序实例是什么样子  const Vue = { createApp(options) { // 暴露给浏览器平台  const renderer = Vue.createRenderer({ querySelector(selector) { return document.querySelector(selector) }, insert(child, parent, anchor) { parent.insertBefore(child, anchor || null) }, createElement(tag) { return document.createElement(tag) } }) return renderer.createApp(options) }, createRenderer({ querySelector, insert, createElement }) { // 返回自定义的渲染器  return { createApp(options) { // 返回的就是app实例  return { mount(selector) { // mount的目标是什么？  const parent = querySelector(selector) // 需要将组件配置解析为dom  //通过render函数实现  if (!options.render) { options.render = this.compile(parent.innerHTML) } // 兼容options api  if (options.setup) { // setupState已经是一个代理对象  this.setupState = options.setup() } else { this.data = options.data() } // Proxy  // 确定render中数据从哪获取  this.proxy = new Proxy(this, { get(target, key) { if (key in target.setupState) { return target.setupState[key] } else { return target.data[key] } }, set(target, key, val) { if (key in target.setupState) { target.setupState[key] = val } else { target.data[key] = val } } }) // app实例上加了一个更新函数  this.update = effect(() =\u0026gt; { // const el = options.render.call(this.proxy)  // // 追加到宿主元素上去  // parent.innerHTML = \u0026#39;\u0026#39;  // // parent.appendChild(el)  // insert(el, parent)  // 获取虚拟dom  const vnode = options.render.call(this.proxy) // mounted  if (!this.isMounted) { // mounted  // vnode =\u0026gt; dom  const el = this.createElm(vnode) parent.innerHTML = \u0026#39;\u0026#39; insert(el, parent) this.isMounted = true } else { // update  // diff  this.patch(this._vnode, vnode) } this._vnode = vnode }) // 初始化  this.update() }, createElm(vnode) { // 创建根节点  const el = createElement(vnode.tag) // todo props  // children  if (typeof vnode.children === \u0026#39;string\u0026#39;) { el.textContent = vnode.children } else { // 递归  vnode.children.forEach(child =\u0026gt; { insert(this.createElm(child), el) }) } vnode.el = el return el }, // n1: 老节点  // n2: 新节点  patch(n1, n2) { const el = n2.el = n1.el // 判断双方是否是相同节点  if (n1.tag === n2.tag) { // tots props  // children  const oldCh = n1.children const newCh = n2.children if (typeof oldCh === \u0026#39;string\u0026#39;) { if (typeof newCh === \u0026#39;string\u0026#39;) { // text  if (oldCh !== newCh) { el.textContent = newCh } } else { // replace text with elements  el.textContent = \u0026#39;\u0026#39; newCh.forEach(child =\u0026gt; insert(this.createElm(child), el)) } } else { if (typeof newCh === \u0026#39;string\u0026#39;) { // replace elements with text  el.textContent = newCh } else { // children  } } } }, compile(template) { // 没有用到template  return function render() { // const h3 = document.createElement(\u0026#39;h3\u0026#39;)  // h3.textContent = this.title  // return h3  // 返回vnode  return h(\u0026#39;h3\u0026#39;, null, this.title) // return h(\u0026#39;h3\u0026#39;, null, [  // h(\u0026#39;p\u0026#39;, null, this.title),  // ])  } } } } } } } \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 函数式  // 2. 标准化、简化、一致性:render函数，sync修饰符删除，指令定义，v-model调整  // 3. tree-shaking（摇树优化）  // 4. 复用性：composition api  // 5. 性能优化：响应式、编译期优化  // 6. 扩展性：自定义渲染器  const { createApp } = Vue const app = createApp({ data() { return { title: \u0026#39;hello vue3!\u0026#39; } }, setup() { // 调函数等等  // 规避this  const state = reactive({ title: \u0026#39;hello vue3!!!!!!\u0026#39; }) setTimeout(() =\u0026gt; { state.title = \u0026#39;vue3, hello!!!!!!\u0026#39; }, 2000) return state }, }) // app.component()  // app.directive(\u0026#39;focus\u0026#39;, {})  app.mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; ","date":"2021-05-20","permalink":"/zh-cn/posts/webnotes/learn_vue/","series":["前端"],"tags":["VUE"],"title":"学习VUE"},{"categories":["学习笔记"],"content":"JavaScript中的协程以及实现生产者消费者模式\n生产者消费者模式输出示例\r class Apple { static price = 10; constructor() { this.type = \u0026#39;红富士\u0026#39;; this.location = \u0026#39;邯郸\u0026#39;; this.taste = \u0026#39;甜\u0026#39;; this.price = Apple.price; } toString() { return `[${Apple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } class Penapple { static price = -817; constructor() { this.type = \u0026#39;呆湾凤梨\u0026#39;; this.location = \u0026#39;呆湾\u0026#39;; this.taste = \u0026#39;酸\u0026#39;; this.price = Penapple.price; } toString() { return `[${Penapple.name}] {type: ${this.type}, loc: ${this.location}, taste: ${this.taste}, price: ${this.price}}`; } } function produce (Goods) { function make (cName, i, delay = 1000) { console.log(`[生产者] 正给${cName}生产第${i}个${Goods.name}...，预计需要${delay}ms`); return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(new Goods()); }, delay); }); } return async function (c, num, delay) { const cName = c.next().value; for (let i = 1; i \u0026lt;= num; i++) { const freshGoods = await make(cName, i, delay); const cRes = c.next(freshGoods).value; console.log(`[消费者反馈] ${cRes}`); } } } function* consumer (name) { let r = name; let n; while (true) { n = yield r; if (!n) { r = \u0026#39;没给我东西啊！\u0026#39;; continue; } console.log(`[消费者 ${name}] 正买 ${n}`); r = `我是${name}，我买完了`; } } function fruitFactory (fruit) { const fruitMap = { \u0026#39;apple\u0026#39;: Apple, \u0026#39;penapple\u0026#39;: Penapple, }; if (!(fruit in fruitMap)) throw `这个工厂不能生产 ${fruit}`; return produce(fruitMap[fruit]); } (async function main() { const appleProducer = fruitFactory(\u0026#39;apple\u0026#39;); const penappleProducer = fruitFactory(\u0026#39;penapple\u0026#39;); appleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 5000); await penappleProducer(consumer(\u0026#39;张艳\u0026#39;), 5); Penapple.price = 250; penappleProducer(consumer(\u0026#39;魏鑫\u0026#39;), 1, 2000); })(); ","date":"2021-05-18","permalink":"/zh-cn/posts/javascripts/coroutine/","series":["前端"],"tags":["JavaScript","生产者消费者模式","协程"],"title":"JavaScript中的协程与生产者消费者模式"},{"categories":["学习笔记"],"content":"MDN文档的CSS学习笔记\n 小艳艳~\r 1. 改变元素的默认行为  当对浏览器的默认样式不太满意时，可以选定那个元素，加一条CSS规则即可。\n 例如移除无序列表 \u0026lt;ul\u0026gt; 自带的项目符号：\nli { list-style-type: none; } list-style-type属性可以使用自定义字符串甚至emoji，或很多种预设语言，可以查表。\n2. 根据状态确定样式  根据标签的状态确定样式。\n 例如使得没有被访问的链接颜色变为粉色、访问过的链接颜色变为绿色、鼠标悬停则移除下划线：\na:link { color: pink; } a:visited { color: green; } a:hover { text-decoration: none; } 3. 如何构建 CSS 在 HTML 里应用 CSS 在文档中应用 CSS 有三种方法\n外部样式表 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;link\u0026gt; 元素的 href 属性需要引用你的文件系统中的一个文件。\n内部样式表 将 CSS 直接写在 HTML 文件 \u0026lt;head\u0026gt; 标签里的 \u0026lt;style\u0026gt; 标签之中。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 内联样式 存在于 HTML 元素的 style 属性之中。每个 CSS 表只影响一个元素。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;color: blue;background-color: yellow;border: 1px solid black;\u0026#34;\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026#34;color:red;\u0026#34;\u0026gt;This is my first CSS example\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 属性和值 在 css 中，属性和值都是区分大小写的。\r\r函数 大多数值都是简单的关键字或数值，但也有一些可能的值以函数的形式出现。例如 calc() 函数、transform属性使用的 rotate() 函数。\n规则 有些 @rules 规则很简单，有规则名和值。例如，要将额外的样式表导入主 CSS 样式表，可以使用 @import：\n@import \u0026#39;styles2.css\u0026#39;; 还有一个最常见的 @rules 之一是 @media，它允许使用媒体查询来应用 CSS，仅当某些条件成立（例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时）。\nbody { background-color: pink; } @media (min-width: 30em) { body { background-color: blue; } } 速记属性 一些常用的：\ndiv { padding: 10px 15px 15px 5px; } 与这四行代码是等价的：\ndiv { padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; } div { background: red url(bg-graphic.png) 10px 10px repeat-x fixed; } 与这五行代码是等价的：\ndiv { background-color: red; background-image: url(bg-graphic,png); background-position: 10px 10px; background-repeat: repeat-x; background-attachment: fixed; } 4. CSS 如何运行 CSS运行过程\r 一个真实的 DOM 案例 现在通过一个 HTML 片段来了解 HTML 怎么转化成 DOM\n\u0026lt;p\u0026gt; Let\u0026#39;s use: \u0026lt;span\u0026gt;Cascading\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Style\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;Sheets\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; 对应树形结构为：\nP ├─ \u0026#34;Let\u0026#39;s use:\u0026#34; ├─ SPAN | └─ \u0026#34;Cascading\u0026#34; ├─ SPAN | └─ \u0026#34;Style\u0026#34; └─ SPAN └─ \u0026#34;Sheets\u0026#34; 当浏览器遇到无法解析的 CSS 代码会发生什么 浏览器什么也不会做，继续解析下一个 CSS 样式。\n相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个 CSS 选择器。\n因此，当为一个元素指定多个 CSS 样式的时候，浏览器会加载样式表中的最后的 CSS 代码进行渲染，正因为如此，可以为同一个元素指定多个 CSS 样式来解决有些浏览器不兼容新特性的问题。\n5. 层叠与继承 冲突规则 层叠 当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n优先级 内联 \u0026gt; id \u0026gt; class \u0026gt; tag\n继承 一些设置在父元素上的 css 属性是可以被子元素继承的，有些则不能。\n例如 color 会继承，但 width 不会继承。因为如果复元素的 width 是50%，后代继承 width，那 CSS 就会很难使用了！\n控制继承 CSS 为控制继承提供了四个特殊的通用属性值。每个 css 属性都接收这些值。\ninherit：使该元素属性和父元素相同。即：开启继承。\ninitial：设置为元素属性的初始默认值，默认值由官方 CSS 规范定义。如果没有默认值且该属性是自然继承的，那么会设置为 inherit。\nunset：重置为自然值，即：如果属性是自然继承那么就是 inherit，否则和 initial 一样。\nrevert: 使该元素样式还原成样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置，否则，按浏览器定义样式表中的样式设置，否则，等价于 unset。\n 通俗解释就是：\n 设置了 inherit 就是继承来自祖上的东西。 设置了 initial 就是抛弃祖上的东西另起炉灶从默认值开始，如果没有默认值，就接着继承祖上的东西。 设置了 unset 就是我不发表意见，本来是继承就继承，本来是默认就默认。 设置了 revert 就是推翻一切，从默认样式表重新开始。   重设所有属性值 CSS 的 shorthand 属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(inherit, initial, unset, or revert)。这是一种撤销对样式所作更改的简便方法，以便回到之前已知的起点。\n.fix-this { all: unset; } ","date":"2021-05-16","permalink":"/zh-cn/posts/webnotes/learn_css/","series":["前端"],"tags":["CSS"],"title":"学习CSS"},{"categories":["学习笔记"],"content":"Python的一些使用技巧和有趣的库\n 1. dataclasses  python3.7引入的内置库，实现数据类，可以利用上内置的类型提示\n 使用方法：\nimport dataclasses as dc @dc.dataclass class Person: name: str # 简单说明类型 age: int = 0 # 设置默认值 sex: str = dc.field(default=\u0026#39;male\u0026#39;, repr=False) # 除了默认值，还可通过repr设置是否显示在字符串输出中 # 创建一个Person实例 p1 = Person(\u0026#39;zhangyan\u0026#39;, 25, \u0026#39;female\u0026#39;) print(p1) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;) 还可以通过asdict和astuple将其转换为dict和tuple类型：\nprint(dc.asdict(p1)) # {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(dc.astuple(p1)) # (\u0026#39;zhangyan\u0026#39;, 25, female) dict类型转为dataclass\np2 = {\u0026#39;name\u0026#39;: \u0026#39;zhangyan\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;sex\u0026#39;: \u0026#39;female\u0026#39;} print(Person(**p2)) # Person(name=\u0026#39;zhangyan\u0026#39;, age=25, sex=\u0026#39;female\u0026#39;)  2. namedtuple  给元组命名，元组中的每一项也可以命名；\n创建的元组实例内的值是不能更改的，但可以使用_replace()方法更改值后返回一个新的元组；\n也可以当作一行代码定义一个类；\n也可以当作数据类用，但是无法使用内置的类型提示，不如dataclasses。\n 使用方法：\nfrom collections import namedtuple Color = namedtuple(\u0026#39;Color\u0026#39;, \u0026#39;r g b a\u0026#39;, defaults=[1.0]) # \u0026#39;r g b a\u0026#39;还可以写为\u0026#39;r, g, b, a\u0026#39;或[\u0026#39;r\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] red = Color(255, 0, 0) # 红色 green = Color(0, 255, 0) # 绿色 blue = Color(0, 0, 255) # 蓝色 half_blue = Color(0, 0, 255, 0.5) # 透明度为50%的蓝色 print(half_blue) # Color(r=0, g=0, b=255, a=0.5) half_blue = half_blue._replace(g=233) print(half_blue) orange = Color._make([224, 142, 0, 1]) # 使用_make函数通过传入一个可迭代对象来构建实例，设置了默认值的项依旧不能省略 print(orange) print(orange._asdict()) # OrderedDict([(\u0026#39;r\u0026#39;, 224), (\u0026#39;g\u0026#39;, 142), (\u0026#39;b\u0026#39;, 0), (\u0026#39;a\u0026#39;, 1)]) print(tuple(orange)) # (224, 142, 0, 1)  3. threading  实现类似 JavaScript 中的 setimeout 延迟运行的效果\n 使用方法：\nimport threading def settimeout(func, delay, *args, **kwargs): threading.Timer(delay, func, args, kwargs).start() # 隔一秒输出一个 i，依次为 0 1 2 3 4 for i in range(5): settimeout(lambda x: print(x), i + 1, i) # 隔一秒输出一个 i，依次为 4 4 4 4 4 for i in range(5): settimeout(lambda x: print(i), i + 1, i) # 一秒后一起输出，依次为 44444 for i in range(5): settimeout(lambda x: print(i, end=\u0026#39;\u0026#39;), 1, i) # 一秒后一起输出，顺序随机，例如：43201、12340 for i in range(5): settimeout(lambda x: print(x, end=\u0026#39;\u0026#39;), 1, i)  4. logging  实现日志功能，可以设置显示级别以及保存到日志文件\n 使用方法：\nimport logging # 配置logging默认参数 logging.basicConfig(level=logging.DEBUG, format=\u0026#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s\u0026#39;) # 获取logger logger = logging.getLogger(__name__) # 设置logger级别，级别顺序：DEBUG -\u0026gt; INFO -\u0026gt; WARNING -\u0026gt; ERROR logger.setLevel(level=logging.DEBUG) # 获取保存日志文件的handler handler = logging.FileHandler(\u0026#39;log.txt\u0026#39;) # 设置handler级别 handler.setLevel(logging.INFO) # 获取formatter formatter = logging.Formatter(\u0026#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s\u0026#39;) # 给handler设置formatter handler.setFormatter(formatter) # 给logger添加handler logger.addHandler(handler) # 执行一些测试 logger.info(\u0026#39;start print log\u0026#39;) logger.debug(\u0026#39;do something\u0026#39;) logger.warning(\u0026#39;something maybe fail\u0026#39;) logger.info(\u0026#39;finish\u0026#39;) ","date":"2021-05-12","permalink":"/zh-cn/posts/pythons/python_tips/","series":["python"],"tags":["dataclasses","namedtuple","threading","logging"],"title":"Python小贴士"},{"categories":["待办"],"content":"面试大厂需要了解的知识点\n1. Webpack VS Vite 原理   谈谈 AST 语法树？ 谈谈 babel 的作用？ 如何收集代码依赖？ ES Module 与 CMD 区别？   如何搞懂 webpack 原理呢？手写一个 mini-webpack 是非常直接的方法，比去看原理解析文章效率高多了。\r\r需要做的有：\n 造个轮子 - 手写 Webpack 什么是抽象语法树（AST） 如何分析模块的依赖关系 如何将 ES6 转换为 ES5 读懂 bundle 文件中的天书代码 谁会是下一个 Webpack ","date":"2021-05-06","permalink":"/zh-cn/posts/webnotes/questions/","series":["前端"],"tags":["面试问题"],"title":"待学习的知识"},{"categories":["学习笔记"],"content":"MDN文档的HTML学习笔记\n 1. 嵌入 \u0026lt;iframe\u0026gt; 元素\r sandbox属性 该属性需要在已经支持其他\u0026lt;iframe\u0026gt;功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置。\r\r注意：为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的src属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间。\r\r\u0026lt;embed\u0026gt; 和 \u0026lt;object\u0026gt; 元素\r 这两个元素与\u0026lt;iframe\u0026gt;不同，是用来嵌入多种类型的外部内容的通用嵌入工具，包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容。\n插件是一种对浏览器原生无法读取的内容提供访问权限的软件\r\r 2. 矢量图形SVG\r 快捷方式：\u0026lt;img\u0026gt; 使用 src 属性设置SVG路径\n疑难解答和跨浏览器支持 对于不支持SVG（IE 8及更低版本，Android 2.3 及更低版本）的浏览器，可以从 src 属性引用 PNG 或 JPG ，并使用 srcset 属性 只有最近的浏览器才能识别）来引用 SVG 。 在这种情况下，仅支持浏览器将加载 SVG - 较旧的浏览器将加载 PNG ：\n\u0026lt;img src=\u0026#34;equilateral.png\u0026#34; alt=\u0026#34;triangle with equal sides\u0026#34; srcset=\u0026#34;equilateral.svg\u0026#34;\u0026gt; 还可以使用 SVG 作为 CSS 背景图像，如下所示。 在下面的代码中，旧版浏览器会坚持他们理解的 PNG ，而较新的浏览器将加载 SVG ：\n.svg { background: url(\u0026#34;fallback.png\u0026#34;) no-repeat center; background-image: url(\u0026#34;image.svg\u0026#34;); background-size: contain; } 像上面描述的\u0026lt;img\u0026gt;方法一样，使用 CSS 背景图像插入 SVG 意味着它不能被 JavaScript 操作，并且也受到相同的 CSS 限制。\n在HTML中引入SVG代码  可以在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中 - 这有时称为将SVG内联或内联SVG。确保您的SVG代码在\u0026lt;svg\u0026gt;\u0026lt;/svg\u0026gt;标签中（不要在外面添加任何内容）。\n \u0026lt;svg width=\u0026#34;300\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; fill=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; 优点  将 SVG 内联减少 HTTP 请求，可以减少加载时间。 可以为 SVG 元素分配class和id，并使用 CSS 修改样式。 内联 SVG 是唯一可以在 SVG 图像上使用 CSS 交互（如:focus）和 CSS 动画的方法（即使在常规样式表中）。 可以通过将 SVG 标记包在 \u0026lt;a\u0026gt; 元素中，使其成为超链接。  缺点  这种方法只适用于在一个地方使用的 SVG 。多次使用会导致资源密集型维护（resource-intensive maintenance）。 额外的 SVG 代码会增加 HTML 文件的大小。 浏览器不能像缓存普通图片一样缓存内联 SVG 。 可能会在 \u0026lt;foreignObject\u0026gt; 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。考虑一下仅仅为支持过时的浏览器，而增加额外开销是否真的值得。  示例 遁入智瞳！上勾拳！     3. 响应式图片  目的：学习如何使用 srcset 以及 \u0026lt;picture\u0026gt; 元素，来实现网页中的响应式图片处理方法。\n 新特性 srcset / sizes / \u0026lt;picture\u0026gt; —— 都已经被新版本的现代浏览器和移动浏览器支持。\r\r 分辨率切换：不同的尺寸 两个新属性：srcset 和 sizes 提供额外的资源图像和提示。\n  浏览器根据设备宽度到 sizes 中找到不超过 max-width 的那一项 根据此项后面的像素值 a，到 srcset 中找到不小于这个值的最接近的 b 将 srcset 对应的图片路径作为需要显示的图片路径，以达到省流目的   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/water-320w.jpg 320w, /images/posts/webnotes/learn_html/water-480w.jpg 480w, /images/posts/webnotes/learn_html/water-800w.jpg 800w, /images/posts/webnotes/learn_html/water-1280w.jpg 1280w\u0026#34; sizes = \u0026#34;(max-width: 424px) 320px, (max-width: 767px) 460px, (max-width: 991px) 800px, 1280px\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/water-1280w.jpg\u0026#34; alt=\u0026#34;Drink more water\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕大小下载合适的图片，来省流。\r\r 分辨率切换：相同的尺寸，不同的分辨率 如果想支持多分辨率显示，但希望每个人在屏幕上看到的图片的实际尺寸是相同的，使用 srcset 和 x 语法结合——一种更简单的语法——而不用 sizes ，来选择适当分辨率的图片。\n  浏览器根据设备的 DPR（即设备像素比），从 srcset 中找到像素比最接近的图片路径 将此路径的图片显示出来，图片的大小由 CSS 样式表中的 width 值来定义 浏览器会保证图片在任何设备上的物理大小一致   \u0026lt;img srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png, /images/posts/webnotes/learn_html/mercy-480w.png 1.5x, /images/posts/webnotes/learn_html/mercy-800w.png 2.5x, /images/posts/webnotes/learn_html/mercy-1280w.png 4x\u0026#34; src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34; style=\u0026#34;width: 180px;\u0026#34;\u0026gt; 效果：\n总结：该方式会使浏览器根据设备屏幕像素密度来决定使用哪个版本的图片，并根据 `width` 的值保证图片在所有设备上实际大小一致。\r\r 美术设计  使用 \u0026lt;picture\u0026gt; 元素实现当屏幕缩小时动态得使用对应像素的图片，将内容适应小屏幕观看，例如人物更大的低分辨率图片。\n \u0026lt;picture\u0026gt; \u0026lt;!-- 小手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 424px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-320w.png\u0026#34;\u0026gt; \u0026lt;!-- 大手机 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 767px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-480w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑竖屏 --\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 991px)\u0026#34; srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-800w.png\u0026#34;\u0026gt; \u0026lt;!-- 平板电脑横屏 / 笔记本电脑 --\u0026gt; \u0026lt;source srcset=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.png\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/posts/webnotes/learn_html/mercy-1280w.jpg\u0026#34; alt=\u0026#34;Overwatch mercy\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 效果（调整浏览器宽度以查看变化）：\n   应该仅仅在美术设计场景下使用media属性；当使用media时，不要在sizes属性中也提供媒体条件。\r\r 为什么不能使用 CSS 或 JavaScript 来做到这一效果？ 如果使用CSS或JavaScript来实现这一效果，在这之前原始图像已经被加载了，然后CSS或JavaScript又加载了一个小的图像，反而浪费发了流量。\n 大胆使用现代图像格式 新图像格式（例如 WebP 和 JPEG-2000）可以在有高质量的同时有较低的文件大小。但是浏览器支持情况不同。\n可以使用 \u0026lt;picture\u0026gt; 来继续满足老式浏览器的需要。可以在 type 属性中提供 MIME 类型，这样浏览器就能立即拒绝不支持的类型：\n\u0026lt;picture\u0026gt; \u0026lt;source type=\u0026#34;image/svg+xml\u0026#34; srcset=\u0026#34;***.svg\u0026#34;\u0026gt; \u0026lt;source type=\u0026#34;image/webp\u0026#34; srcset=\u0026#34;***.webp\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;***.png\u0026#34; alt=\u0026#34;example image\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt;  不要使用 media 属性，除非需要美术设计。 在 \u0026lt;source\u0026gt; 元素中，只可以引用在 type 中声明的文件类型。 如果必要，可以在 srcset 和 sizes 中使用逗号分割的列表。 ","date":"2021-05-05","permalink":"/zh-cn/posts/webnotes/learn_html/","series":["前端"],"tags":["HTML"],"title":"学习HTML"},{"categories":["Shortcode"],"content":"本文展示了如果使用 alert shortcode。\n{{\u0026lt; alert \u0026#34;Message\u0026#34; [type] \u0026gt;}}  The parameter type is optional. Default to info.\n Info {{\u0026lt; alert \u0026#34;Info\u0026#34; \u0026gt;}} Info\r\rSuccess {{\u0026lt; alert \u0026#34;Success\u0026#34; success \u0026gt;}} Success\r\rWarning {{\u0026lt; alert \u0026#34;Warning\u0026#34; warning \u0026gt;}} Warning\r\rDanger {{\u0026lt; alert \u0026#34;Danger\u0026#34; danger \u0026gt;}} Danger\r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/alert/","series":["用户手册"],"tags":["Alert"],"title":"Alert Shortcode"},{"categories":["Shortcode"],"content":"关于哔哩哔哩 shortcode 的详细使用说明。\n使用 {{\u0026lt; bilibili \u0026#34;video id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/bilibili/","series":null,"tags":["哔哩哔哩"],"title":"Bilibili Shortcode"},{"categories":["Shortcode"],"content":"关于 CodePen shortcode 的详细说明。\n使用 {{\u0026lt; codepen \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/codepen/","series":null,"tags":["CodePen"],"title":"CodePen Shortcode"},{"categories":["Shortcode"],"content":"关于 JSFiddle shortcode 的详细说明。\n使用 {{\u0026lt; jsfiddle \u0026#34;user/id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/jsfiddle/","series":null,"tags":["JSFiddle"],"title":"JSFiddle Shortcode"},{"categories":["Shortcode"],"content":"关于 JSRun shortcode 的详细说明。\n使用 {{\u0026lt; jsrun \u0026#34;id\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/jsrun/","series":null,"tags":["JSRun"],"title":"JSRun Shortcode"},{"categories":["Shortcode"],"content":"关于优酷 shortcode 的详细说明。\n使用 {{\u0026lt; youku \u0026#34;XNTQwMTgxMTE2\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/youku/","series":null,"tags":["Youku"],"title":"优酷 Shortcode"},{"categories":["Shortcode"],"content":"关于爱奇艺 shortcode 的详细说明。\n使用 {{\u0026lt; iqiyi \u0026#34;vid\u0026#34; \u0026#34;tvid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/iqiyi/","series":null,"tags":["爱奇艺"],"title":"爱奇艺 Shortcode"},{"categories":["Shortcode"],"content":"关于网易云音乐 Shortcode 的详细使用说明。\n使用 {{\u0026lt; neteasemusic \u0026#34;id\u0026#34; [auto [type]] \u0026gt;}}    Parameter Description     auto The auto controls whether to autoplay. Boolean and optional, default to false.   type The type parameter is optional. Default to 2.    例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/neteasemusic/","series":null,"tags":["网易云音乐"],"title":"网易云音乐 Shortcode"},{"categories":["Shortcode"],"content":"关于腾讯视频 shortcode 的详细说明。\n使用 {{\u0026lt; tencentvideo \u0026#34;vid\u0026#34; \u0026gt;}} 例子 \r","date":"2020-10-22","permalink":"/zh-cn/posts/shortcodes/tencentvideo/","series":null,"tags":["腾讯视频"],"title":"腾讯视频 Shortcode"}]